#!/usr/bin/perl
# -*- mode: perl; indent-tabs-mode: t; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=perl
#
# Author: Andrew Theurer
#
# Rickshaw-post-process-bench will run the benchmark-specific post-process script
# for every iteration/sample/client|server.  This is required after running
# rickshaw-run, which runs the benchmarks and puts the result in --base-run-dir

use strict;
use warnings;
use Cwd;
use Data::UUID;
use File::pushd;
use File::Basename;
use File::Temp qw(tempdir);
use File::Copy;
use File::Path qw(make_path);
use JSON::XS;
use JSON::Validator;
use Data::Dumper;

my $ug = Data::UUID->new;
my $debug = 0;
my %run; # A multi-dimensional, nested hash, schema TBD
         # This hash documents what was run.

my $base_run_dir;
my $run_file;    # 'rickshaw-run.json' containing all configuration data
                 # (generated by 'rickshaw-run' once a run is complete)
my $result_file; # 'rickshaw-result.json' containing all configuration and result data
                 # (generated by this script)

sub usage {
    print "\nusage:\n\n";
    print "--base-run-dir  Directory where result data is located for a previous 'rickshaw-run'\n";
}

sub debug_log {
    if ($debug) {
        print "[DEBUG]" . shift;
    }
}

sub dump_params {
    my $params_ref = shift;
    my $cs_id = shift;
    my $params_str = "";
    foreach my $param (@{ $params_ref }) {
        my $arg = $$param{'arg'};
        my $val = $$param{'val'};
        if (defined $val && length $val) {
            if (defined $cs_id) {
                $val =~ s/\%client-id\%/$cs_id/;
            }
            $params_str .= " --" . $arg . "=" . $val;
        } else {
            $params_str .= " --" . $arg;
        }
    }
    $params_str =~ s/^\s//;
    return $params_str;
}

sub put_json_file {
    my $filename = shift;
    my $json_ref = shift;
    my $schema_filename = shift;
    my $coder = JSON::XS->new->canonical->pretty;
    if (defined $schema_filename and -e $schema_filename) {
        my $jv = JSON::Validator->new;
        open(FH, $schema_filename) or die "Could not open $schema_filename";
        my $json_text;
        while ( <FH> ) {
            $json_text .= $_;
        }
        close FH;
        $jv->schema($json_text);
        debug_log(sprintf "Going to validate schema with [%s]\n", $schema_filename);
        my @errors = $jv->validate($json_ref);
        if (scalar @errors >  0) {
            printf "Validation errors for file %s with schema %s:\n", $filename, $schema_filename;
            print Dumper \@errors;
            exit 1;
        }
    }
    debug_log(sprintf "trying to write [%s]\n", $filename);
    my $json_text = $coder->encode($json_ref);
    open(JSON_FH, ">" . $filename) || die("Could not open file $filename\n");
    printf JSON_FH "%s", $json_text;
    close JSON_FH;
}

sub get_json_file {
    my $filename = shift;
    my $schema_filename = shift;
    my $coder = JSON::XS->new;
    debug_log(sprintf "trying to open [%s]\n", $filename);
    open(FH, $filename) || die("Could not open file $filename\n");
    my $json_text = "";
    while ( <FH> ) {
        $json_text .= $_;
    }
    close FH;
    my $json_ref = $coder->decode($json_text) || die "Could not read JSON";
    if (defined $schema_filename and -e $schema_filename) {
        my $jv = JSON::Validator->new;
        open(FH, $schema_filename) or die "Could not open $schema_filename";
        my $json_text;
        while ( <FH> ) {
            $json_text .= $_;
        }
        close FH;
        $jv->schema($json_text);
        my @errors = $jv->validate($json_ref);
        if (scalar @errors >  0) {
            printf "Validaton errors for file %s with schema %s:\n", $filename, $schema_filename;
            print Dumper \@errors;
            exit 1;
        }
    }
    return $json_ref;
}


my $rickshaw_project_dir;
{
    # Get the absolute path of the rickshaw project directory
    my $dir = pushd(dirname($0));
    $rickshaw_project_dir = getcwd();
}
my $bench_schema_file = $rickshaw_project_dir . "/schema/benchmark.json";
my $bench_metric_schema_file = $rickshaw_project_dir . "/schema/bench-metric.json";
my $run_schema_file = $rickshaw_project_dir . "/schema/run.json";
my $result_schema_file = $rickshaw_project_dir . "/schema/result.json";
my %bench_config;

# Process the cmdline params
while (scalar @ARGV > 0) {
    my $p = shift @ARGV;
    debug_log(sprintf "processing \@ARGV, param: [%s]\n", $p);
    my $arg;
    my $val;

    if ( $p =~ /^\-\-(\S+)/ ) {
        $arg = $1;
        if ( $arg =~ /^(\S+)=(.*)/ ) { # '--arg=val'
            $arg = $1;
            $val = $2;
        } else { # '--arg val'
            $val = shift @ARGV;
        }
    } else {
        print "[ERROR]malformed cmdline parameter: %s\n";
        usage;
        exit 1;
    }
    debug_log(sprintf "processing \@ARGV, arg is: [%s], val is: [%s]\n", $arg, $val);
    if ($arg =~ /^help$/) {
        usage;
        exit 0;
    } elsif ($arg =~ /^base-run-dir$/) {
        debug_log(sprintf "argument: [%s]\n", $arg);
        $base_run_dir = $val;
    } else {
        printf "[ERROR]argument not valid: [%s]\n", $arg;
        usage;
        exit 1;
    }
}


# Ensure the run-dir hase absolute path
{
    my $dir = pushd($base_run_dir);
    debug_log(sprintf "pushd to [%s]\n", $base_run_dir);
    my $cwd = getcwd();
    debug_log(sprintf "cwd [%s]\n", $cwd);
    $base_run_dir = $cwd;
}
my $config_dir = $base_run_dir . "/config";
my $run_dir = $base_run_dir . "/run";
my $iter_dir = $run_dir . "/iterations";

# Load the existing rickshaw-run.json
$run_file = $run_dir . "/rickshaw-run.json";
if (-e $run_file) {
    printf "opening %s\n", $run_file;
    my $run_ref = get_json_file($run_file, $run_schema_file);
    %run = %{ $run_ref };
    # TODO checks for minimum fileds for valid run
} else {
    printf "Could not find rickshaw-run.json in %s, exiting\n", $run_dir;
    exit 1;
}

# Load the bench config and user params
#exists $run{'bench-dir'} || die "The rickshaw-run.json must have 'bench-dir' defined\n";
if (! exists $run{'bench-dir'}) {
    # Try to locate the bench subproject based on the rickshaw_project_dir
    {
        my $dir = pushd($rickshaw_project_dir . "/../../../subprojects/benchmarks/" . $run{'benchmark'});
        $run{'bench-dir'} = getcwd();
        printf "Assuming bench-dir is %s\n", $run{'bench-dir'};
    }
}
my $bench_config_file = $run{'bench-dir'} . "/rickshaw.json";
if (-e $bench_config_file) {
    my $bench_config_ref = get_json_file($bench_config_file, $bench_schema_file);
    %bench_config = %{ $bench_config_ref };
    if (! exists $bench_config{'benchmark'}) {
        printf "Could not determine benchmark from %s\n", $bench_config_file;
        exit 1;
    }
    if ($bench_config{'benchmark'} ne $run{'benchmark'}) {
        printf "Benchmark name from rickshaw-run.json [%s] and name from " .
               "bench subproject config file [%s] do not match, exiting\n",
               $run{'benchmark'}, $bench_config{'benchmark'};
    }
} else {
    printf "[ERROR]benchmark subproject config file %s was not found\n", $bench_config_file;
    exit 1;
}

printf "Launching a post-process job for each iteration x sample x [client|server] for %s\n", $run{'benchmark'};
my $pp_cmd = $bench_config{'controller'}{'post-script'};
$pp_cmd =~ s/\%bench-dir\%/$run{'bench-dir'}\//g;
$pp_cmd =~ s/\%run-dir\%/$run_dir\//g;
$pp_cmd =~ s/\%config-dir\%/$config_dir\//g;
my @pids;
for (my $i = 1; $i <= scalar @{ $run{'iterations'} }; $i++) {
    my $iter_params = dump_params($run{'iterations'}[$i - 1]{'params'});
    my $iter_dh;
    my $this_iter_dir = $iter_dir . "/iteration-" . $i;
    opendir($iter_dh, $this_iter_dir);
    my @samp_dirs = grep(/^sample-\d+/, readdir($iter_dh));
    my $iter_array_idx = $i -1;
    my @samples;
    my $primary_metric;
    my $primary_period;
    for my $samp_dir (@samp_dirs) {
        my %sample; # sample data from all clients/servers
        my @cons_periods; # consolidated periods across clients/servers get merged here
        my $this_samp_dir = $this_iter_dir . "/" .  $samp_dir;
        debug_log("Working on " . $this_samp_dir . "\n");
        opendir(my $samp_dh, $this_samp_dir);
        my @cs_names = grep(/^(client|server)$/, readdir($samp_dh));
        for my $cs_name (@cs_names) { 
            my $cs_name_dir = $this_samp_dir . "/" . $cs_name;
            opendir(my $cs_name_dh, $cs_name_dir);
            my @cs_ids = grep(/^(\d+)$/, readdir($cs_name_dh));
            for my $cs_id (@cs_ids) {
                my $cs_id_dir = $cs_name_dir . "/" . $cs_id;
                if (my $pid = fork) {
                    push(@pids, $pid);
                } else {
                    my $pushd_dir = pushd($cs_id_dir);

                    my $rc = system($pp_cmd . " " . $iter_params);
                    if ($rc == -1) {
                        printf "Failed to execute '%s%s'!\n", $pp_cmd, $iter_params;
                    } elsif ($rc & 127) {
                        printf "'%s%s' died with signal %d, %s coredump!\n", $pp_cmd, $iter_params, ($rc & 127), ($rc & 128) ? 'with' : 'without';
                    } else {
                        $rc = $rc >> 8;
                        if ($rc != 0) {
                           printf "'%s%s' exited with non-zero value %d\n", $pp_cmd, $iter_params, $rc;
                        }
                    }

                    exit;
                }
            }
        }
    }
}
printf "Waiting for %d post-processing jobs to complete\n", scalar @pids;
while (wait() > -1) {}
print "Post-processing complete\n";
