#!/usr/bin/env bash
# -*- mode: perl; indent-tabs-mode: t; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash

function exit_error() {
    local message=$1; shift
    local code=$1; shift
    echo -e "[ERROR]$message\n"
    echo "Exiting"
    if [ -z "$code" ]; then
        exit 1
    else
        exit $code
    fi
}

function do_roadblock() {
    local label=$1; shift
    local timeout=$1; shift
    local extra=$1; shift
    if [ -z "$label" ]; then
        exit_error "[ERROR]do_roadblock() label not provided"
    fi
    if [ -z "$timeout" ]; then
        exit_error "[ERROR]do_roadblock() timeout not provided"
    fi
    local cmd=""
    cmd="$cmd $roadblock_bin --role=follower --redis-server=$roadblock_server"
    cmd="$cmd --timeout=$timeout --redis-password=$roadblock_passwd"
    cmd="$cmd --uuid=$roadblock_id:$label --follower-id=$cs_label --leader-id=controller $extra"
    if [ "$use_roadblock" == "1" ]; then
        echo "going to run this roadblock command: $cmd"
        local output=`$cmd 2>&1`
        local rc=$?
        echo -e "$output"
        if echo $output | grep -q -P -- '(Exiting\swith\sabort|Roadblock\sCompleted\swith\san\sAbort)'; then
            rc=4
        fi
        if echo $output | grep -q -P -- '(The\sroadblock\shas\stimed\sout|ERROR:\sRoadblock\sfailed\swith\stimeout)'; then
            exit_error "Roadblock timeout: $output"
        fi
        if [ $rc -gt 0 ]; then
            echo "Roadblock exit code is non-zero: $rc"
        fi
        return $rc
    fi
    return 0
}

function scp_from_controller() {
    local ssh_id_file=$1; shift
    local src=$1; shift
    local dest=$1; shift
    if [ -z "$ssh_id_file" ]; then
        exit_error "scp_from_controller(): ssh_id_file not defined"
    fi
    if [ -z "$src" ]; then
        exit_error "scp_from_controller(): src not defined"
    fi
    if [ -z "$dest" ]; then
        exit_error "scp_from_controller(): dest not defined"
    fi
    local scp_attempts=1
    local scp_rc=1
    local max_attempts=10
    scp_cmd="scp -o StrictHostKeyChecking=no"
    scp_cmd+=" -o BatchMode=yes"
    scp_cmd+=" -v"
    scp_cmd+=" -o ConnectionAttempts=10"
    scp_cmd+=" -i $ssh_id_file"
    scp_cmd+=" -r $rickshaw_host:$src $dest"
    while [ $scp_rc -gt 0 -a $scp_attempts -lt $max_attempts ]; do
        echo "Trying to scp $rickshaw_host:$src $dest"
        scp_output=`$scp_cmd 2>&1`
        scp_rc=$?
        if [ $scp_rc -gt 0 ]; then
            echo "scp failed, trying again"
            echo "scp exit code: $scp_rc"
            echo "scp command: $scp_cmd"
            echo "scp output:"
            echo "$scp_output"
            sleep $scp_attempts
        fi
        let scp_attempts=$scp_attempts+1
    done
    if [ $scp_attempts -ge $max_attempts ]; then
        exit_error "Could not copy $src from $rickshaw_host"
    fi
}

function archive_to_controller() {
    local ssh_id_file=$1; shift
    local src=$1; shift # a directory to archive from
    local dest=$1; shift # a destination directory to write archive
    local ssh_attempts=1
    local ssh_rc=1
    local max_attempts=10
    if [ -z "$ssh_id_file" ]; then
        exit_error "archive_to_controller(): ssh_id_file not defined"
    fi
    if [ -z "$src" ]; then
        exit_error "archive_to_controller(): src_file not defined"
    fi
    if [ -z "$dest" ]; then
        exit_error "archive_to_controller(): destination is not defined"
    fi
    pushd $src || exit_error "Could not chdir to $src"
    while [ $ssh_rc -gt 0 -a $ssh_attempts -lt $max_attempts ]; do
        echo "Trying to tar/ssh fron $src to $rickshaw_host:$dest"
        tar czf - . | ssh \
                       -o StrictHostKeyChecking=off \
                       -o ConnectionAttempts=10 \
                       -i "/tmp/rickshaw_id.rsa" \
                       $rickshaw_host "dd of=$dest"
        ssh_rc=$?
        echo "ssh exit code: $ssh_rc"
        if [ $ssh_rc -gt 0 ]; then
            echo "tar/ssh failed, trying again"
            sleep $ssh_attempts
        fi
        let ssh_attempts=$ssh_attempts+1
    done
    popd >/dev/null
    if [ $ssh_attempts -ge $max_attempts ]; then
        exit_error "Could not archive $src to $rickshaw_host:$dest"
    fi
}

echo "client-server-script env:"
env
echo "client-server-script params:"
echo "$@"

version=100
echo "version: $version"
longopts="rickshaw-host:,base-run-dir:,endpoint-run-dir:,cs-label:,roadblock-server:"
longopts="${longopts},roadblock-passwd:,roadblock-id:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    exit_error "\nUnrecognized option specified: $@\n\n"
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --rickshaw-host)
            shift;
            rickshaw_host="$1"
            shift;
            ;;
        --base-run-dir)
            shift;
            base_run_dir=$1
            shift;
            ;;
        --cs-label)
            shift;
            cs_label="$1"
            shift;
            ;;
        --endpoint-run-dir)
            shift;
            endpoint_run_dir="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            roadblock_server="$1"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            roadblock_passwd="$1"
            shift;
            ;;
        --roadblock-id)
            shift;
            roadblock_id="$1"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
           exit_error "Unexpected argument [$1]"
           shift;
           break;
           ;;
    esac
done

if [ -z "$endpoint_run_dir" ]; then
    exit_error "The endpoint run directory (--endpoint-run-dir) was not defined"
fi
if [ -z "$cs_label" ]; then
    exit_error "The client/server label (--cs-label) was not defined"
fi
if echo $cs_label | grep -q -P '^(\w+)-\d+$'; then
    echo "client_label \"$cs_label\" is valid"
else
    exit_error 'cs_label "'$cs_label'" does not adhere to regex /^(\w+)-\d+$/'
fi
export RS_CS_LABEL=$cs_label

# Directories on the client/server
cs_dir="`mktemp -d`"
echo "cs_dir: $cs_dir"
tool_start_cmds="$cs_dir/tool-start"
tool_stop_cmds="$cs_dir/tool-stop"

cs_type=`echo $cs_label | awk -F- '{print $1}'`
cs_id=`echo $cs_label | awk -F- '{print $2}'`

# Directories on the controller
config_dir="$base_run_dir/config"
client_server_config_dir="$config_dir/client-server"
tool_cmds_dir="$config_dir/tool-cmds/$cs_type"
tool_cmds_dir="$config_dir/tool-cmds/$cs_type"
run_dir="$base_run_dir/run"
archives_dir="$run_dir/client-server/archives"

if [ -z "$rickshaw_host" ]; then
	exit_error "Exiting due to rickshaw host not being set"
fi

roadblock_bin="/usr/local/bin/roadblock.py"
use_roadblock=1
if [ -z "$roadblock_server" ]; then
    echo "Cannot use roadblock for synchronizaton because a server was not provided"
    use_roadblock=0
fi
if [ -z "$roadblock_id" ]; then
    echo "Cannot use roadblock for synchronizaton because an ID was not provided"
    use_roadblock=0
fi
if [ -z "$roadblock_passwd" ]; then
    echo "Cannot use roadblock for synchronizaton because a password was not provided"
    use_roadblock=0
fi

if [ "$use_roadblock" == "1" ]; then
    if [ ! -e $roadblock_bin ]; then
        exit_error "Could not find roadblock binary: $roadblock_bin"
    fi
fi

pushd "$cs_dir" >/dev/null || exit_error "Could not chdir to $cs_dir"

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-script-start
    do_roadblock $label 300
else
    label=collector-script-start
    do_roadblock $label 300
fi

ssh_id_file="/tmp/rickshaw_id.rsa"
if [ ! -z "$ssh_id" ]; then
   echo -e "$ssh_id" > $ssh_id_file
   chmod 600 $ssh_id_file
fi
if [ ! -e $ssh_id_file ]; then
    exit_error "ssh key $ssh_id_file was not found"
fi

# Get files required to run benchmark and tools
cs_files_list="$cs_type-files-list"
# First get the file that tells us what other files to get
scp_from_controller "$ssh_id_file" "$client_server_config_dir/$cs_files_list" "$cs_files_list"
if [ ! -e "$cs_files_list" ]; then
    exit_error "Could not find $cs_files_list"
fi
dest_file=""
src_file=""
# Now we know what files to get
while read line; do
    # $cs_files_list has line like:
    # src=<file>
    # dest=<file>
    # (then repeat)
    if [ -z "$src_file" ]; then
        src_file=`echo $line | grep "^src=" | awk -F= '{print $2}'`
        if [ -z "$src_file" ]; then
            exit_error "source file not found in $cs_type-file-list"
        fi
    else 
        dest_file=`echo $line | grep "^dest=" | awk -F= '{print $2}'`
        if [ -z "$dest_file" ]; then
            exit_error "dest file not found in $cs_type-file-list"
        fi
        scp_from_controller "$ssh_id_file" "$src_file" "$dest_file"
        dest_file=""
        src_file=""
    fi
done < "$cs_files_list"

# Get the benchmark and tool commands
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    cs_start_bench_cmds="$cs_label-start-bench.cmds"
    scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/start" "bench-start-cmds"
    if [ ! -e "bench-start-cmds" ]; then
        exit_error "bench cmds file bench-start-cmds not found. PWD: `/bin/pwd`  LS: `/bin/ls`"
    fi
    if [ "$cs_type" == "server" ]; then
        scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/stop" "bench-stop-cmds"
        if [ ! -e "bench-stop-cmds" ]; then
            exit_error "bench cmds file bench-stop-cmds not found. PWD: `/bin/pwd`  LS: `/bin/ls`"
        fi
    fi
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/$cs_id/start" "$tool_start_cmds"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/$cs_id/stop" "$tool_stop_cmds"
else
    # non-client/server get tool cmds based on endpoint-specific collector = $cs_label like "worker"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/start" "$tool_start_cmds"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/stop" "$tool_stop_cmds"
fi

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    # Regular clients/servers sync with the controller before starting tools
    label=client-server-start-tools
    do_roadblock $label 300
else
    # Non client/servers, "collectors", sync with the endpoint that created them
    # because the controller does not know how many collectors there are, but
    # the endpoint does.
    label=collector-start-tools
    do_roadblock $label 300
fi

for this_tool_cmds in "$tool_start_cmds" "$tool_stop_cmds"; do
    if [ ! -e $this_tool_cmds ]; then
        exit_error "Tool cmd file $this_tool_cmd was not found"
    fi
done
mkdir -p tool-data
pushd tool-data >/dev/null
while read line; do
    tool_name=`echo $line | awk -F: '{print $1}'`
    tool_cmd=`echo $line | sed -e s/^$tool_name://`
    /bin/mkdir -p $tool_name
    pushd $tool_name >/dev/null
    $tool_cmd
    popd >/dev/null
done <"$tool_start_cmds"
popd >/dev/null

declare -A bench_start_cmds
declare -A bench_stop_cmds
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    count=0
    if [ -e bench-start-cmds ]; then
        while read line; do
            bench_start_cmds[$count]="$line"
            let count=$count+1
        done < bench-start-cmds
    else
        exit_error "bench-start-cmds not found"
    fi
fi
if [ "$cs_type" == "server" ]; then
    if [ -e bench-stop-cmds ]; then
        count=0
        while read line; do
            bench_stop_cmds[$count]="$line"
            let count=$count+1
        done < bench-stop-cmds
    else
        exit_error "bench-stop-cmds not found"
    fi
fi
    
# Run the actual tests by reading the commands file
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    echo ${bench_start_cmds[@]}
    len=${#bench_start_cmds[@]}
    for (( i=0; i<$len; i++ )); do
        iter_samp=`echo ${bench_start_cmds[$i]} | awk '{print $1}'`
        start_cmd=`echo ${bench_start_cmds[$i]} | sed -e s/^$iter_samp//`
        if [ "$cs_type" == "server" ]; then
            stop_cmd=`echo ${bench_stop_cmds[$i]} | sed -e s/^$iter_samp//`
        fi
        iter=`echo $iter_samp | awk -F- '{print $1}'`
        samp=`echo $iter_samp | awk -F- '{print $2}'`
        iter_samp_dir="$cs_dir/iteration-$iter/sample-$samp"
        mkdir -p $iter_samp_dir ||
            exit_error "Could not mkdir iteration-$iter/sample-$samp"
        find . -mindepth 1 -maxdepth 1 -type f | grep -v -- "$cs_label-stderrout.txt" | \
            grep -v -- "$cs_label-bench.cmds" | grep -v -- "$cs_label-tool.cmds" | \
            grep -v -- "$cs_files_list" | \
            cpio -pdum iteration-$iter/sample-$samp/ ||
            exit_error "Could not copy files from $cs_dir to $iter_samp_dir with find & cpio"
        pushd $iter_samp_dir || exit_error "Could not chdir to $iter_samp_dir"
        echo PWD: `/bin/pwd`
        for sync in server-start client-start client-stop server-stop; do
            label="test-${iter}-${samp}:$sync"
            do_roadblock "$label" 300 "$abort_opt"
            rb_rc=$?
            cmd_rc=0
            echo roadblock $label exit code: $rb_rc
            if [ $rb_rc -eq 4 ]; then
                echo -e "\nAbort exit code from iteration $iter, sample $samp roadblock"
                echo -e "\nWill not run remaining tests\n"
                break 2 # break out of the outer loop
            fi
            if [ $rb_rc -eq 2 ]; then
                exit_error "roadblock for client-server-start-test:$iter-$samp timed out"
            fi
            # These combinations don't run a command:
            #  sync=server-start & cs_type=client
            #  sync=client-start & cs_type=server
            #  sync=server-stop & cs_type=client
            if [ "$sync" == "server-start" -a "$cs_type" == "server" ]; then
                echo "Running $sync command: $start_cmd"
                $start_cmd
                cmd_rc=$?
            elif [ "$sync" == "client-start" -a "$cs_type" == "client" ]; then
                echo "Running $sync command: $start_cmd"
                $start_cmd
                cmd_rc=$?
            elif [ "$sync" == "server-stop" -a "$cs_type" == "server" ]; then
                echo "Running $sync command: $stop_cmd"
                $stop_cmd
                cmd_rc=$?
            fi
            if [ $cmd_rc -gt 0 ]; then
                # An abort message must be sent so the other members know how to procede
                abort_opt=" --abort"
                echo -e "\nNon-zero exit code from iteration $iter, sample $samp"
                echo -e "\nWill not run remaining tests\n"
            fi
        done
        popd >/dev/null  # from $iter_sampl_dir back to $cs_dir
        echo PWD: `/bin/pwd`
    #done < "$cs_bench_cmds"
    done
fi

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-stop-tools
    do_roadblock $label 300
    echo -e "\nClients/servers stopping tools"
else
    label=collector-stop-tools
    do_roadblock $label 300
    echo -e "\nCollectors stopping tools"
fi
pushd tool-data >/dev/null
while read line; do
    tool_name=`echo $line | awk -F: '{print $1}'`
    tool_cmd=`echo $line | sed -e s/^$tool_name://`
    pushd $tool_name >/dev/null
    $tool_cmd
    popd >/dev/null
done <"$tool_stop_cmds"
popd >/dev/null

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-send-data
    do_roadblock $label 300
    echo -e "\nClients/servers copying data back to controller"
else
    label=collector-send-data
    do_roadblock $label 300
    echo -e "\nCollectors copying data back to controller"
fi

# Send all of the test data to the controller and remove local data
archive_to_controller "$ssh_id_file" "$cs_dir" "$archives_dir/$cs_label-data.tgz"
/bin/rm -rf $cs_dir

popd >/dev/null
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-script-finish
    do_roadblock $label 300
    echo -e "\nAll client/server scripts are finished"
else
    label=collector-script-finish
    do_roadblock $label 300
    echo -e "\nAll collector scripts are finished"
fi
