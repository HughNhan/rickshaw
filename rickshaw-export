#!/usr/bin/perl
# -*- mode: perl; indent-tabs-mode: t; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=perl
#
# Author: Andrew Theurer
#
# Rickshaw will run a benhcmark for you.  Please see README.md for instructions.

use strict;
use warnings;
use Cwd;
use Data::UUID;
use File::pushd;
use File::Basename;
use File::Temp qw(tempdir);
use File::Copy;
use File::Path qw(make_path);
use JSON::XS;
use JSON::Validator;
use Data::Dumper;
use REST::Client;

my $debug = 0;
my %result;
my $base_run_dir;
my %cdm = ( 'ver' => 'v5dev' );
my $coder = JSON::XS->new->canonical;

sub usage {
    print "\nusage:\n\n";
    print "--base-run-dir <dir>  (this is a result-file in json that rickshaw-post-process generates)\n";
}

sub debug_log {
    if ($debug) {
        print "[DEBUG]" . shift;
    }
}

sub put_json_file {
    my $filename = shift;
    chomp $filename;
    my $json_ref = shift;
    my $schema_filename = shift;
    my $coder = JSON::XS->new->canonical->pretty;
    if (defined $schema_filename and -e $schema_filename) {
        chomp $schema_filename;
        my $jv = JSON::Validator->new;
	my $schema_fh = new IO::Uncompress::UnXz $schema_filename, Transparent => 1 || die "Could not open file " . $schema_filename;
        my $json_schema_text;
        while ( <$schema_fh> ) {
            $json_schema_text .= $_;
        }
        close($schema_fh);
        chomp $json_schema_text;
        $jv->schema($json_schema_text);
        debug_log(sprintf "Going to validate schema with [%s]\n", $schema_filename);
        my @errors = $jv->validate($json_ref);
        if (scalar @errors >  0) {
            printf "Validation errors for file %s with schema %s:\n", $filename, $schema_filename;
            print Dumper \@errors;
            exit 1;
        }
    }
    debug_log(sprintf "trying to write [%s]\n", $filename);
    my $json_text = $coder->encode($json_ref);
    my $json_fh;
    if ($filename =~ /xz$/) {
	$json_fh = new IO::Compress::Xz "$filename" || die("Could not open $filename.xz for writing\n");
    } else {
	open($json_fh, ">", $filename);
    }
    printf $json_fh "%s", $json_text;
    close($json_fh);
}

sub get_json_file {
    my $filename = shift;
    chomp $filename;
    my $schema_filename = shift;
    my $coder = JSON::XS->new;
    debug_log(sprintf "trying to open [%s]\n", $filename);
    my $log_fh = new IO::Uncompress::UnXz $filename, Transparent => 1 || die "Could not open file " . $filename;
    my $json_text = "";
    while ( <$log_fh> ) {
        $json_text .= $_;
    }
    close($log_fh);
    chomp $json_text;
    my $json_ref = $coder->decode($json_text) || die "Could not read JSON";
    if (defined $schema_filename and -e $schema_filename) {
        chomp $schema_filename;
        my $jv = JSON::Validator->new;
	my $schema_fh = new IO::Uncompress::UnXz $schema_filename, Transparent => 1 || die "Could not open file " . $schema_filename;
        my $json_schema_text;
        while ( <$schema_fh> ) {
            $json_schema_text .= $_;
        }
        close($schema_fh);
        chomp $json_schema_text;
        $jv->schema($json_schema_text);
        my @errors = $jv->validate($json_ref);
        if (scalar @errors >  0) {
            printf "Validaton errors for file %s with schema %s:\n", $filename, $schema_filename;
            print Dumper \@errors;
            exit 1;
        }
    }
    return $json_ref;
}

sub export_metric {
    my $metr_ref = shift; # the rickshaw metric object
    my $base_doc_ref = shift; # metric_desc doc gets populated with this, usually a run doc or period doc
    my $coder = JSON::XS->new->canonical;
    # Copy data from 'parent' doc so querying directly for metric_desc with
    # run data is possible
    my %metr_desc_doc = %$base_doc_ref;
    $metr_desc_doc{'metric_desc'} = $$metr_ref{'desc'};
    $metr_desc_doc{'metric_desc'}{'id'} = Data::UUID->new->create_str();
    $metr_desc_doc{'metric_desc'}{'names'} = $$metr_ref{'names'};
    my $metr_desc_doc_json = $coder->encode(\%metr_desc_doc);
    http_request("POST", "localhost:9200", "/cdmv5dev-metric_desc/_doc/", $metr_desc_doc_json);
    my $count = 0;
    my $ndjson = "";
    for my $metr_data (@{ $$metr_ref{'data'} }) {
        # The metric_data docs do not include the 'parent' doc info
        # because there are potentially millions and millions of these.
        # The only data copied from its parent (metric_desc) is the metric_desc.id
        my %metr_data_doc = ( 'metric_data' => $metr_data, 'cdm' => \%cdm );
        $metr_data_doc{'metric_desc'}{'id'} = $metr_desc_doc{'metric_desc'}{'id'};
        my $metr_data_doc_json = $coder->encode(\%metr_data_doc);
        $ndjson .= sprintf "%s\n", '{ "index": {} }';
        $ndjson .= sprintf "%s\n", $metr_data_doc_json;
        $count++;
        if ($count >= 1000) {
            http_ndjson_request("POST", "localhost:9200", "/cdmv5dev-metric_data/_doc/_bulk", $ndjson);
            $ndjson = "";
            $count = 0;
        }
    }
    if ($count > 0) {
        http_ndjson_request("POST", "localhost:9200", "/cdmv5dev-metric_data/_doc/_bulk", $ndjson);
    }
}

sub http_request {
    my $method = shift;
    my $host = shift;
    my $req = shift;
    my $body = shift;
    my $client = REST::Client->new();
    $client->setHost($host);
    my %req_header = ("Content-Type" => "application/json");
    #debug_log(sprintf "%s:\nRequest: http://%s/%s\nbody: %s\n\n", $desc, $host, $req, $body);
    $client->request($method, $req, $body, \%req_header);
    my $response = $client->responseContent();
    #debug_log($response);
    return $response;
}

sub http_ndjson_request {
    my $method = shift;
    my $host = shift;
    my $req = shift;
    my $body = shift;
    my $client = REST::Client->new();
    $client->setHost($host);
    my %req_header = ("Content-Type" => "application/x-ndjson");
    #debug_log(sprintf "%s:\nRequest: http://%s/%s\nbody: %s\n\n", $desc, $host, $req, $body);
    $client->request($method, $req, $body, \%req_header);
    my $response = $client->responseContent();
    #debug_log($response);
    return $response;
}

# Process the cmdline params
while (scalar @ARGV > 0) {
    my $p = shift @ARGV;
    debug_log(sprintf "processing \@ARGV, param: [%s]\n", $p);
    my $arg;
    my $val;

    if ( $p =~ /^\-\-(\S+)/ ) {
        $arg = $1;
        if ( $arg =~ /^(\S+)=(.*)/ ) { # '--arg=val'
            $arg = $1;
            $val = $2;
        } else { # '--arg val'
            $val = shift @ARGV;
        }
    } else {
        print "[ERROR]malformed cmdline parameter: %s\n";
        usage;
        exit 1;
    }
    debug_log(sprintf "processing \@ARGV, arg is: [%s], val is: [%s]\n", $arg, $val);
    if ($arg =~ /^help$/) {
        usage;
        exit 0;
    } elsif ($arg =~ /^base-run-dir$/) {
        debug_log(sprintf "argument: [%s]\n", $arg);
        $base_run_dir = $val;
    } else {
        printf "[ERROR]argument not valid: [%s]\n", $arg;
        usage;
        exit 1;
    }
}

# Ensure the run-dir hase absolute path
{
    my $dir = pushd($base_run_dir);
    debug_log(sprintf "pushd to [%s]\n", $base_run_dir);
    my $cwd = getcwd();
    debug_log(sprintf "cwd [%s]\n", $cwd);
    $base_run_dir = $cwd;
}
my $rickshaw_project_dir; # We need the project dir to load schemas to validate json
{
    # Get the absolute path of the rickshaw project directory
    my $dir = pushd(dirname($0));
    $rickshaw_project_dir = getcwd();
}
my $config_dir = $base_run_dir . "/config";
my $run_dir = $base_run_dir . "/run";
my $iter_dir = $run_dir . "/iterations";
my $result_schema_file = $rickshaw_project_dir . "/schema/result.json";

my $result_file = $run_dir . "/rickshaw-result.json";
if (! -e $result_file) {
    $result_file = $run_dir . "/rickshaw-result.json.xz";
}
if (-e $result_file) {
    printf "Opening %s\n", $result_file;
    my $result_ref = get_json_file($result_file, $result_schema_file);
    %result = %{ $result_ref };
    # TODO checks for minimum fileds for valid run
} else {
    printf "Could not find rickshaw-result.json in %s, exiting\n", $run_dir;
    exit 1;
}


# Start by creating what will be the CDM run document for elasticsearch
my %run = ( 'id' => $result{'run-id'}, 'harness' => 'rickshaw', 'benchmark' => $result{'benchmark'},
            'host' => 'localhost', 'name' => $result{'name'}, 'email' => $result{'email'} );
for my $field (qw(host name email desc)) {
    if (defined $result{$field}) {
        $run{$field} = $result{$field};
    }
}

printf "Exporting from %s to elasticsearch documents and POSTing to localhost:9200\n", $result_file;
printf "Run ID: %s\n", $result{'run-id'};
my $response = http_request("POST", "localhost:9200", "/cdmv5dev-run/_doc/_search/", '{"query":{"bool":{"filter":[{"term":{"run.id":"' . $result{'run-id'} . '"}}]}},"size":1000}');

#printf("response:\n%s\n", $response);
my $response_ref = $coder->decode($response);
#print "response" . Dumper $response_ref;
if ($$response_ref{'hits'}{'total'}{'value'} > 0) {
    print "Run ID already exists, so will not POST to elasticsearch\n";
    print "Either delete existing run from ES or regenerate rickshaw-result.json\n";
    exit 1;
}
my %run_doc = ( 'cdm' => \%cdm, 'run' => \%run );
my $run_doc_json = $coder->encode(\%run_doc);
my $curl_cmd = "curl --stderr /dev/null -H \'Content-Type: application/json\'";
http_request("POST", "localhost:9200", "/cdmv5dev-run/_doc/", $run_doc_json);
if (exists $result{'tool-data'}) {
    print "Working on tool data\n";
    my $run_doc_ref = $coder->decode($run_doc_json);
    for my $metr (@{ $result{'tool-data'} }) {
        export_metric($metr, $run_doc_ref);
    }
}
if (exists $result{'tags'}) {
    for my $tag (@{ $result{'tags'} }) {
        # Copy data from 'parent' doc so querying directly for tags with
        # run/iteration data is possible
        my $tag_doc_ref = $coder->decode($run_doc_json);
        my %tag_doc = %$tag_doc_ref;
        $tag_doc{'tag'}{'id'} = Data::UUID->new->create_str();
        $tag_doc{'tag'}{'name'} = $$tag{'name'};
        $tag_doc{'tag'}{'val'} = $$tag{'val'};
        my $tag_doc_json = $coder->encode(\%tag_doc);
        http_request("POST", "localhost:9200", "/cdmv5dev-tag/_doc/", $tag_doc_json);
    }
}
if (exists $result{'iterations'}) {
    my $iter_num = 1;
    for my $iter (@{ $result{'iterations'} }) {
        printf "Working on iteration %d\n", $iter_num;
        my $iter_doc_ref = $coder->decode($run_doc_json);
        my %iter_doc = %$iter_doc_ref;
        $iter_doc{'iteration'}{'id'} = Data::UUID->new->create_str();
        $iter_doc{'iteration'}{'primary-metric'} = $$iter{'primary-metric'};
        $iter_doc{'iteration'}{'primary-period'} = $$iter{'primary-period'};
        my $iter_doc_json = $coder->encode(\%iter_doc);
        http_request("POST", "localhost:9200", "/cdmv5dev-iteration/_doc/", $iter_doc_json);
        for my $param (@{ $$iter{'params'} }) {
            # Copy data from 'parent' doc so querying directly for params with
            # run/iteration data is possible
            my $param_doc_ref = $coder->decode($iter_doc_json);
            my %param_doc = %$param_doc_ref;
            $param_doc{'param'}{'id'} = Data::UUID->new->create_str();
            $param_doc{'param'}{'arg'} = $$param{'arg'};
            $param_doc{'param'}{'val'} = $$param{'val'};
            my $param_doc_json = $coder->encode(\%param_doc);
            http_request("POST", "localhost:9200", "/cdmv5dev-param/_doc/", $param_doc_json);
        }
        my $sample_num = 1;
        for my $samp (@{ $$iter{'samples'} }) {
            # Copy data from 'parent' doc so querying directly for samples with
            # run/iteration data is possible
            my $samp_doc_ref = $coder->decode($iter_doc_json);
            my %samp_doc = %$samp_doc_ref;
            $samp_doc{'sample'}{'id'} = Data::UUID->new->create_str();
            $samp_doc{'sample'}{'num'} = $sample_num;
            $samp_doc{'sample'}{'status'} = $$samp{'status'};
            my $samp_doc_json = $coder->encode(\%samp_doc);
            http_request("POST", "localhost:9200", "/cdmv5dev-sample/_doc/", $samp_doc_json);
            $sample_num++;
            for my $per (@{ $$samp{'periods'} }) {
                # Copy data from 'parent' doc so querying directly for samples with
                # run/iteration/sample data is possible
                my $per_doc_ref = $coder->decode($samp_doc_json);
                my %per_doc = %$per_doc_ref;
                $per_doc{'period'}{'id'} = Data::UUID->new->create_str();
                $per_doc{'period'}{'name'} = $$per{'name'};
                $per_doc{'period'}{'begin'} = $$per{'begin'};
                $per_doc{'period'}{'end'} = $$per{'end'};
                my $per_doc_json = $coder->encode(\%per_doc);
                http_request("POST", "localhost:9200", "/cdmv5dev-period/_doc/", $per_doc_json);
                for my $metr (@{ $$per{'metrics'} }) {
                    my $per_doc_ref = $coder->decode($per_doc_json);
                    export_metric($metr, $per_doc_ref);
                }
            }
        }
        $iter_num++;
    }
}
print "Export to CDM complete\n";
