#!/usr/bin/env bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash

# This script implements the 'k8s' endpoint for rickshaw.  It runs 1 or more
# clients (and no servers, yet) for as many benchmark interations/samples as required
# for a single invocation of rickshaw.  Like all enpoints, this is meant to be used
# with other endpoints for creating multi-cloud tests.
#
# Usage:
# local [--validate] --endpoint-opts=host=<host>,user=<user>,client:n-m,o-p,server:n-m,o-p 
#                    --run-id <id> --base-run-dir --image-id <id>
#                    --roadblock-server <host> --roadblock-id <id> --roadblock-passwd=<passwd>
#
# If --validate is used all options after client/server will be ignored
#
# TODO: This endpoint script was copied from 'local' endpoint and has some common function.
#       Some of that code could probably be consolidated into a library or utilities.
#       Utilities may work better since other endpoint may be written in a different language.
# TODO: There are a significant number of features we need to implement for pod preferences:
#       - node placement for pods/containers
#       - multus support
#       - pod requests and limits
#       - running benchmark servers and setting up the service and router
#       - containers/pod options
#       - implement tool execution outside the client/server pods (on workers and masters with
#         privileged pods)
#       - collecting information of pod creation and execution
#       - implementing a system info collection of a k8s cluster
#       - using a user-definable container registry for container image sourcing
#         - this is hard-coded right now
#         - rickshaw needs changes to publish locally built images (from workshop) to the user's
#           registry
#         - all endpoint scripts will need to make this change when rickshaw supports this
#
# All of the functions that a client-server-script performs works in this endpoint, such as:
# - benchmark iteration/sample execution
# - using a container image which has the required software
# - tool execution
# - synchronization of execution
# - sending tool and benchmark data back to the controller (where this endpoint script runs)

function exit_error() {
    echo "$1"
    exit 1
}

function do_roadblock() {
    local label=$1; shift
    local role=$1; shift
    # followers or members in $@
    if [ -z "$label" ]; then
        exit_error "do_roadblock(): label not defined"
    fi
    if [ -z "$role" ]; then
        exit_error "do_roadblock(): role not defined"
    fi
    if [ -z "$1" ]; then
        exit_error "do_roadblock(): follower or members not defined"
    fi
    if [ $use_rb -eq 0 ]; then
        echo "Not running roadblock"
        return 0
    fi
    echo `date` "Starting roadblock"
    echo "role: $role"
    echo "label: $label"
    local uuid="$rb_id:$label"
    local cmd="/usr/local/bin/roadblock.py"
    cmd+=" --redis-server $rb_server --timeout 300 --redis-password $rb_passwd --uuid $uuid"
    if [ "$role" == "follower" ]; then
        cmd+=" --role follower --follower-id $1"
        echo "follower-id: $1"
    elif [ "$role" == "leader" ]; then
        cmd+=" --role leader --uuid $uuid"
        local followers=""
        while [ ! -z $1 ]; do
            cmd+=" --followers $1"
            followers+=" $1"
            shift
        done
        echo "followers: $followers"
    else
        exit_error "Roadblock role \"$role\" invalid"
    fi
    local output=`$cmd 2>&1`
    local rc=$?
    if echo $output | grep -q -- "Received abort message"; then
        echo $output
        rc=3
    fi
    if echo $output | grep -q -- "The roadblock has timed out"; then
        exit_error "$output"
    fi
    if [ $rc -gt 0 ]; then
        echo "Roadblock exit code is non-zero: $rc"
        echo $output
    fi
    echo `date` "Completed roadblock for $uuid"
    echo "output:"
    echo "$output"
    return $rc
}

function build_pod_spec() {
local name=$1; shift # name of the pod, also the file name with .json appended
local type=$1; shift # "cs" or "tool"
local dir=$1; shift # what directory to store the pod spec file
local container_names=$1; shift # a list of container names for this pod, which is typically the client/server labels
local pod_json="$dir/$name.json"

    echo "{" >$pod_json
    echo "  \"apiVersion\": \"v1\"," >>$pod_json
    echo "  \"kind\": \"Pod\"," >>$pod_json
    echo "  \"metadata\": {" >>$pod_json
    echo "    \"name\": \"$name\"" >>$pod_json
    echo "  }," >>$pod_json
    echo "  \"spec\": {" >>$pod_json
    if [ ! -z "$nodeSelector" ]; then
        echo -e "$nodeSelector," >>$pod_json
    fi
    echo "    \"restartPolicy\": \"Never\"," >>$pod_json
    echo "    \"containers\": [" >>$pod_json

    count=0
    for container_name in ${container_names}; do
        if [ $count -gt 0 ]; then
            echo "      ,{" >>$pod_json
        else
            echo "      {" >>$pod_json
        fi
        echo "        \"name\": \"$container_name\"," >>$pod_json
        echo "        \"image\": \"quay.io/atheurer/workshop-rhubi8_uperf:latest\"," >>$pod_json
        echo "        \"imagePullPolicy\": \"Always\"," >>$pod_json
        echo "        \"env\": [" >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"rickshaw_host\"," >>$pod_json
        echo "            \"value\": \"$hostname\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"base_run_dir\"," >>$pod_json
        echo "            \"value\": \"$base_run_dir\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"cs_label\"," >>$pod_json
        echo "            \"value\": \"$container_name\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"endpoint_run_dir\"," >>$pod_json
        echo "            \"value\": \"/endpoint-run\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"roadblock_server\"," >>$pod_json
        echo "            \"value\": \"$rb_server\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"roadblock_passwd\"," >>$pod_json
        echo "            \"value\": \"flubber\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"roadblock_id\"," >>$pod_json
        echo "            \"value\": \"$rb_id\"" >>$pod_json
        echo "          }," >>$pod_json
        echo "          {" >>$pod_json
        echo "            \"name\": \"ssh_id\"," >>$pod_json
        printf "            \"value\": \"" >>$pod_json
        sed -z 's/\n/\\n/g' $config_dir/rickshaw_id.rsa >>$pod_json
        echo "\"" >>$pod_json
        echo "          }" >>$pod_json
        echo "        ]" >>$pod_json
        if [ "$type" == "collector" ]; then
            echo "        ,\"securityContext\": {" >>$pod_json
            echo "          \"privileged\": true" >>$pod_json
            echo "        }" >>$pod_json 
        else
            if [ ! -z "$securityConext" ]; then
                echo -e ",$securityConext" >>$pod_json
            fi
            if [ ! -z "$resources" ]; then
                echo -e ",$resources" >>$pod_json
            fi
        fi
        echo "      }" >>$pod_json
        let count=$count+1
    done
    echo "    ]" >>$pod_json
    echo "  }" >>$pod_json
    echo "}" >>$pod_json
}

endpoint_name="k8s"
tool_collectors="master worker"
hostname=`hostname`
longopts="validate,endpoint-opts:,endpoint-label:,run-id:,base-run-dir:,image-id:"
longopts="$longopts,roadblock-server:,roadblock-passwd:,roadblock-id:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    printf -- "\tUnrecognized option specified\n\n"
    exit 1
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --validate)
            do_validate=1
            shift;
            ;;
        --endpoint-opts)
            shift;
            endpoint_opts="$1"
            shift;
            ;;
        --endpoint-label)
            shift;
            endpoint_label="$1"
            shift;
            ;;
        --run-id)
            shift;
            run_id="$1"
            shift;
            ;;
        --base-run-dir)
            shift;
            base_run_dir="$1"
            shift;
            ;;
        --image-id)
            shift;
            image_id="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            rb_server="$1"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            rb_passwd="$1"
            shift;
            ;;
        --roadblock-id)
            shift;
            rb_id="$1"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
           exit_error "Unexpected argument [$1]"
           shift;
           break;
           ;;
    esac
done

for opt in `echo $endpoint_opts | sed -e 's/,/ /g'`; do
    arg=`echo $opt| awk -F: '{print $1}'`
    val=`echo $opt | awk -F: '{print $2}'`
    case "$arg" in
        client|server|clients|servers)
            for ids in `echo $val | sed -e 's/,/ /'`; do
                if echo $ids | grep -q -- "-"; then
                    range=`echo $ids | sed 's/-/ /'`
                    for j in `seq $range`; do
                        if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                            clients[$j]="client-$j"
                        elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                            servers[$j]="server-$j"
                        fi
                    done
                else
                    if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                        clients[$ids]="client-$ids"
                    elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                        servers[$ids]="server-$ids"
                    fi
                fi
            done
            ;;
        host)
            k8s_host=$val
            ;;
        user)
            k8s_user=$val
            ;;
        nodeSelector)
            if [ -e $val ]; then
                nodeSelector=`cat $val`
            fi
            ;;
        securityContext)
            if [ -e $val ]; then
                securityContext=`cat $val`
            fi
            ;;
        resources)
            if [ -e $val ]; then
                resources=`cat $val`
            fi
            ;;
        *)
            exit_error "endpoint options $arg not supported"
            ;;
    esac
done

# Validation just returns what clients and servers would be used
if [ "$do_validate" == 1 ]; then
    if [ ${#clients[@]} -gt 0 ]; then
        echo "client ${!clients[@]}"
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "[ERROR]This endpoint does not support servers yet"
        exit 1
    fi
    #TODO: validate host and user and KUBECONFIG
    exit
fi

# Also exit if asking for servers even in not in --validate
if [ ${#servers[@]} -gt 0 ]; then
    echo "[ERROR]This endpoint does not support servers yet"
    exit 1
fi

k8s_kubeconfig=`ssh -o StrictHostKeyChecking=no $k8s_user@$k8s_host env | grep ^KUBECONFIG | awk -F"KUBECONFIG=" '{print $2}'`
if [ -z "$k8s_kubeconfig" ]; then
    echo "[ERROR]KUBECONFIG on k8s host $k8s_host not defined"
    exit 1
fi
k8s_nodes=`ssh -o StrictHostKeyChecking=no $k8s_user@$k8s_host kubectl get nodes`
echo -e "k8s nodes:\n$k8s_nodes"


# Figure out if we run roadblock or not
if [ -z "$rb_server" -o -z "$rb_passwd" -o -z "$rb_id" ]; then
    echo "Not using roadblock to synchronize since some or all options were missing"
    use_rb=0
    rb_do_exit=0
    if [ ${#clients[@]} -gt 1 ]; then
        echo "Refusing to run because roadblock is not being used and number of clients is > 1"
        rb_do_exit=1
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "Refusing to run because roadblock is not being used and servers are used"
        rb_do_exit=1
    fi
    if [ "$rb_do_exit" == "1" ]; then
        exit_error "Exiting do to roadblock/client/server conflict"
    fi
else
    use_rb=1
fi


# Exit if other reqs are not met
if [ -z "$run_id" ]; then
    exit_error "The run ID was not provided"
fi
if [ -z "$base_run_dir" ]; then
    exit_error "--base-run-dir was not provided"
fi
if [ ! -d "$base_run_dir" ]; then
    exit_error "The run directory [$base_run_dir] does not exist"
fi
config_dir="$base_run_dir/config"
client_server_config_dir="$config_dir/client-server"
client_server_bench_cmds_dir="$client_server_config_dir/bench-cmds"
run_dir="$base_run_dir/run"
client_server_logs_dir="$run_dir/client-server/logs"
endpoint_run_dir="$run_dir/endpoint/$endpoint_label"
cs_pod_specs_dir=$endpoint_run_dir/cs-pod-specs
tool_pod_specs_dir=$endpoint_run_dir/tool-pod-specs

if [ ! -e "$config_dir/rickshaw_id.rsa" ]; then
    exit_error "ssh key file $config_dir/rickshaw_id.rsa was not found"
fi

mkdir -p $endpoint_run_dir
mkdir -p $cs_pod_specs_dir
mkdir -p $tool_pod_specs_dir
mkdir -p $client_server_logs_dir
kubectl_nodes_json="$endpoint_run_dir/kubectl-get-nodes.json"
kubectl_pods_json="$endpoint_run_dir/kubectl-get-pods.json"

# Gather some k8s data
echo "Getting k8s nodes information"
ssh $k8s_user@$k8s_host kubectl get nodes -o json >$kubectl_nodes_json
# Run any tools necessary for "master" and "worker" collectors, as 
# "master" and "worker" are the only two collector-types k8s endpoint recognizes
#
# Identify the workers and masters
nr_nodes=`jq '.items | length' $kubectl_nodes_json`
masters=""
workers=""
for node in `seq 0 $(expr $nr_nodes - 1)`; do
    name=`jq '.items['$node'] | .metadata.name' $kubectl_nodes_json`
    echo "name: $name"
    if [ "$(jq '.items['$node'] | .metadata.labels | has("node-role.kubernetes.io/master")' $kubectl_nodes_json)" == "true" ]; then
        echo "found master"
        masters="$masters $name"
    fi
    if [ "$(jq '.items['$node'] | .metadata.labels | has("node-role.kubernetes.io/worker")' $kubectl_nodes_json)" == "true" ]; then
        echo "found worker"
        workers="$workers $name"
    fi
done

# Create the pod spec files
/bin/rm -rf /tmp/pod-specs
pod_names=""
for client in ${clients[@]}; do
    # By default use one client per pod
    pod_name="rickshaw-$client"
    build_pod_spec "$pod_name" "cs" "$cs_pod_specs_dir" "$client"
    pod_names="$pod_names $pod_name"
done

# Create the client/server pods
echo "Copying client/server pod specs to k8s cluster"
ssh $k8s_user@$k8s_host /bin/rm -rf /tmp/cs-pod-specs
scp -r $cs_pod_specs_dir $k8s_user@$k8s_host:/tmp/
echo "Deleting existing pods"
echo ssh $k8s_user@$k8s_host kubectl delete pod $pod_names
ssh $k8s_user@$k8s_host kubectl delete pod $pod_names
for this_pod in $pod_names; do
    echo "Creating pod $this_pod on $k8s_user@$k8s_host"
    ssh $k8s_user@$k8s_host kubectl create -f /tmp/cs-pod-specs/$this_pod.json
done

declare -A pod_status
for pod in $pod_names; do
    pod_status["$pod_name"]=""
done
count=0
abort=0
status=""
until [ "$status" == "Running" -o $count -gt 24 -o $abort -gt 0 ]; do
    # TODO: parsing kubectl's json would be more reliable
    for this_status in `ssh $k8s_user@$k8s_host kubectl get pods -o wide | grep rickshaw | awk '{print $3}'`; do
        status=$this_status
        echo "pod status: $status"
        if [ "$this_status" != "Error" ]; then
            abort=1
            break
        fi
        if [ "$this_status" != "Running" ]; then
            break
        fi
    done
done

# Figure out which worker nodes are running these pods
ssh $k8s_user@$k8s_host kubectl get pods -o json >$kubectl_pods_json
if [ ! -e $kubectl_pods_json ]; then
    exit_error "file $kubectl_pods_json not found"
fi
pod_workers=`jq -r '.items[] | .metadata.name + " " +  .spec.nodeName' $kubectl_pods_json |\
             grep ^\rickshaw-client | awk '{print $2}' | sort | uniq`
echo "worker nodes running client-server pods: $pod_workers"
count=1
pod_names=""
collectors=""
# Create a tool pod for each worker node that runs client/server pods
for worker_node in $pod_workers; do
    pod_name="rickshaw-tool-$count"
    collector="worker-$count"
    build_pod_spec "$pod_name" "collector" "$tool_pod_specs_dir" "worker-$count"
    pod_names+=" $pod_name"
    collectors+=" $collector"
done
echo "Collectors: $collectors"

# Create the tool pods
echo "Copying tool pod specs to k8s cluster"
ssh $k8s_user@$k8s_host /bin/rm -rf /tmp/tool-pod-specs
scp -r $tool_pod_specs_dir $k8s_user@$k8s_host:/tmp/
echo "Deleting existing pods"
echo ssh $k8s_user@$k8s_host kubectl delete pod $pod_names
ssh $k8s_user@$k8s_host kubectl delete pod $pod_names
for this_pod in $pod_names; do
    echo "Creating pod $this_pod on $k8s_user@$k8s_host"
    ssh $k8s_user@$k8s_host kubectl create -f /tmp/tool-pod-specs/$this_pod.json
done

echo "This endpiont deployed"
do_roadblock "endpoint-deploy" "follower" "$endpoint_label"

# The next roadblock does not sync until the controller (rickshaw/leader) finishes a
# "client/server-finish" sync

# The following is for participating in the roadblock syncs for each benchmark execution.
# The endpoint does not really need to participate in this, but if it does not, it will
# wait on the next roadblock sync (endpoint-move-data) and likely time out when there are
# lots of iterations/samples to run.  Rather than trying to predict a good time period
# to execute all of these tests, it is easier to just participate in the roadblock syncs
# for all of the tests, then run the endpoint-move-data roadblock sync.
for sub_label in script-start start-tools; do
    do_roadblock "collector-$sub_label" "leader" "$collectors"
    do_roadblock "client-server-$sub_label" "follower" "$endpoint_label"
done

if [ ! -e "$client_server_bench_cmds_dir/client/1" ]; then
    exit_error "client bench cmd file $client_server_bench_cmds_dir/client/1 not found"
fi
# Process the first client's bench-commands to participate in the roadblocks
while read line; do
    iter_samp=`echo $line | awk '{print $1}'`
    iter=`echo $iter_samp | awk -F- '{print $1}'`
    samp=`echo $iter_samp | awk -F- '{print $2}'`
    for sync in server-start client-start client-stop server-stop; do
        label="test-${iter}-${samp}:$sync"
        do_roadblock "$label" "follower" "$endpoint_label"
        rb_rc=$?
        echo "roadblock $label exit code: $rb_rc"
        if [ $rb_rc -eq 3 ]; then
            echo -e "\nAbort exit code from iteration $iter, sample $samp"
            echo -e "\nWill not run remaining tests\n"
            break
        fi
    done
done < "$client_server_bench_cmds_dir/client/1/start"

for sub_label in stop-tools send-data script-finish; do
    do_roadblock "collector-$sub_label" "leader" "$collectors"
    do_roadblock "client-server-$sub_label" "follower" "$endpoint_label"
done

# Collect the stdout/err from the pods which run the client-server-script)
for this_pod in $pod_names; do
    echo "Getting logs from pod this_pod"
    this_client_server="`echo $this_pod | sed -e s/^rickshaw-//`.txt"
    ssh $k8s_user@$k8s_host kubectl logs $this_pod >/$client_server_logs_dir/$this_client_server
done

for label in endpoint-move-data endpoint-finish endpoint-really-finish; do
    do_roadblock "$label" "follower" "$endpoint_label"
done

echo "Exiting k8s endpoint script"
exit 0
    label=collector-script-finish
