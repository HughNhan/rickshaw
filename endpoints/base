#!/usr/bin/env bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4 -*-
#set -u

# Shared init and functions for endpoints

echo "#params: $@"
hostname=`hostname`
rb_exit_timeout=3
rb_exit_abort=4
rb_exit_nonet=5
default_timeout=240
max_rb_attempts=5
endpoint_deploy_timeout=360
client_server_start_timeout=720
endpoint_move_data_timeout=300
cs_rb_opts=""
do_validate="0"
num_clients=0
num_servers=0
declare -A clients
declare -A servers

function exit_error() {
    echo "$1"
    echo "going to exit now..."
    exit 1
}

function process_opts() {
    local longopts="validate,endpoint-opts:,endpoint-label:,run-id:,base-run-dir:,image:"
    local longopts="$longopts,roadblock-server:,roadblock-passwd:,roadblock-id:,osruntime:"
    local opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
    if [ $? -ne 0 ]; then
        printf -- "\tUnrecognized option specified\n\n"
        exit 1
    fi
    eval set -- "$opts";
    while true; do
        case "$1" in
            --validate)
                do_validate="1"
                shift;
                ;;
            --endpoint-opts)
                shift;
                endpoint_opts="$1"
                shift;
                ;;
            --endpoint-label)
                shift;
                endpoint_label="$1"
                shift;
                ;;
            --run-id)
                shift;
                run_id="$1"
                shift;
                ;;
            --base-run-dir)
                shift;
                base_run_dir="$1"
                shift;
                ;;
            --image)
                shift;
                image="$1"
                shift;
                ;;
            --roadblock-server)
                shift;
                rb_server="$1"
                cs_rb_opts="$cs_rb_opts --roadblock-server=$rb_server"
                shift;
                ;;
            --roadblock-passwd)
                shift;
                rb_passwd="$1"
                cs_rb_opts="$cs_rb_opts --roadblock-passwd=$rb_passwd"
                shift;
                ;;
            --roadblock-id)
                shift;
                rb_id="$1"
                cs_rb_opts="$cs_rb_opts --roadblock-id=$rb_id"
                shift;
                ;;
            --)
                shift;
                break;
            ;;
            *)
            exit_error "Unexpected argument [$1]"
            shift;
            break;
            ;;
        esac
    done
}

function addto_clients_servers() {
    local arg="$1"; shift
    local val="$1"; shift
    for ids in `echo $val | sed -e 's/,/ /'`; do
        if echo $ids | grep -q -- "-"; then
            range=`echo $ids | sed 's/-/ /'`
            for j in `seq $range`; do
                if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                    clients[$j]="client-$j"
                    let num_clients=$num_clients+1
                elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                    servers[$j]="server-$j"
                    let num_servers=$num_servers+1
                fi
            done
        else
            if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                clients[$ids]="client-$ids"
                let num_clients=$num_clients+1
            elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                servers[$ids]="server-$ids"
                let num_servers=$num_servers+1
            fi
        fi
    done
}

function echo_clients_servers() {
    #if [ ${#clients[@]} -gt 0 ]; then
    if [ $num_clients -gt 0 ]; then
        echo "client ${!clients[@]}"
    fi
    #if [ ${#servers[@]} -gt 0 ]; then
    if [ $num_servers -gt 0 ]; then
        echo "server ${!servers[@]}"
    fi
}

function init_common_dirs() {
    if [ "$do_validate" != 1 ]; then
        config_dir="$base_run_dir/config"
        client_server_config_dir="$config_dir/client-server"
        client_server_bench_cmds_dir="$client_server_config_dir/bench-cmds"
        run_dir="$base_run_dir/run"
        client_server_logs_dir="$run_dir/client-server/logs"
        endpoint_run_dir="$run_dir/endpoint/$endpoint_label"
        bootstrap_script="/usr/local/bin/bootstrap"
        client_server_run_script="/usr/local/bin/client-server-script"
        roadblock_msgs_dir="$endpoint_run_dir/roadblock-msgs"
        mkdir -p "$endpoint_run_dir"
        mkdir -p "$client_server_logs_dir"
        mkdir -p "$roadblock_msgs_dir"
    fi
}

function base_req_check() {
    if [ -z "$rb_server" -o -z "$rb_passwd" -o -z "$rb_id" ]; then
        echo "Not using roadblock to synchronize since some or all options were missing"
        use_rb=0
        cs_rb_opts=""
        rb_do_exit=0
        if [ ${#clients[@]} -gt 1 ]; then
            echo "Refusing to run because roadblock is not being used and number of clients is > 1"
            rb_do_exit=1
        fi
        if [ ${#servers[@]} -gt 0 ]; then
            echo "Refusing to run because roadblock is not being used and servers are used"
            rb_do_exit=1
        fi
        if [ "$rb_do_exit" == "1" ]; then
            exit_error "Exiting do to roadblock/client/server conflict"
        fi
    else
        use_rb=1
    fi
    if [ -z "$run_id" ]; then
        exit_error "The run ID was not provided"
    fi
    if [ -z "$base_run_dir" ]; then
        exit_error "--base-run-dir was not provided"
    fi
    if [ ! -d "$base_run_dir" ]; then
        exit_error "The run directory [$base_run_dir] does not exist"
    fi
    if [ ! -e "$config_dir/rickshaw_id.rsa" ]; then
        exit_error "Could not find $config_dir/rickshaw_id.rsa"
    fi
    if [ ! -e "$client_server_bench_cmds_dir/client/1" ]; then
        exit_error "client bench cmd file $client_server_bench_cmds_dir/client/1 not found"
    fi
}

function do_roadblock() {
    echo "do_roadblock() ARGC: $#"
    local label=$1; shift
    local role=$1; shift
    local timeout=$1; shift
    if [ $# -gt 0 ]; then
        local message="$1"; shift # A file for user-messages or "" if none
        echo "Going to send this user message file: $message"
    else
        local message=""
        echo "Not going to send user message file"
    fi
    ###  followers or members remain in $@  ###
    if [ -z "$role" ]; then
        exit_error "do_roadblock(): role not defined"
    fi
    if [ $use_rb -eq 0 ]; then
        echo "Not running roadblock"
        return 0
    fi

    printf "\n\n"
    echo "Starting roadblock [`date`]"
    echo "role: $role"
    local uuid="$rb_id:$label"
    echo "uuid (without attempt ID embedded): $uuid"
    echo "timeout: $timeout"
    local msgs_file="$roadblock_msgs_dir/$label.json"
    local cmd="/usr/local/bin/roadblock.py"
    cmd+=" --redis-server $rb_server --timeout $timeout --redis-password $rb_passwd --role=$role --message-log=$msgs_file"
    if [ ! -z "$message" ]; then
        cmd+=" --user-message $message"
    fi
    if [ "$role" == "follower" ]; then
        cmd+=" --leader-id controller --follower-id $endpoint_label"
    elif [ "$role" == "leader" ]; then
        if [ -z "$1" ]; then
            exit_error "do_roadblock(): follower(s) not defined"
        fi
        cmd+=" --leader-id endpoint"
        local followers=""
        while [ $# -gt 0 ]; do
            cmd+=" --followers $1"
            followers+=" $1"
            shift
        done
        echo "followers: $followers"
    else
        exit_error "Roadblock role \"$role\" invalid"
    fi

    local attempts=0
    local rc=99
    local output=""
    while [ $attempts -lt $max_rb_attempts -a $rc -ne 0 -a $rc -ne $rb_exit_abort ]; do
        let attempts=$attempts+1
        echo "attempt number: $attempts"
        echo "uuid: $attempts:$uuid"
        output=`$cmd --uuid $attempts:$uuid 2>&1`
        rc=$?
        echo "roadblock output BEGIN"
        printf "%s" "$output"
        echo "roadblock output END"
        echo "roadblock exit code: $rc"

        if echo $output | grep -q -P -- '(Name\sor\sservice\snot\sknown)'; then
            rc=$rb_exit_nonet
        elif echo $output | grep -q -P -- '(Exiting\swith\sabort|Roadblock\sCompleted\swith\san\sAbort)'; then
            rc=$rb_exit_abort
        elif echo $output | grep -q -P -- '(The\sroadblock\shas\stimed\sout|ERROR:\sRoadblock\sfailed\swith\stimeout)'; then
            rc=$rb_exit_timeout
        fi
    done
    echo "total attempts: $attempts"
    echo "Completed roadblock [`date`]"
    printf "\n\n"
    if [ $rc -ne 0 -a $rc -ne $rb_exit_abort ]; then
        exit_error "roadblock failed"
    else
        return $rc
    fi
}

function process_prebench_roadblocks() {
    do_roadblock "endpoint-deploy" "follower" $endpoint_deploy_timeout

    if [ $# -gt 0 ]; then # followers were provided, so run these endpoint-leader syncs
        do_roadblock "collector-script-start" "leader" $client_server_start_timeout "" $@
    fi
    do_roadblock "client-server-script-start" "follower" $client_server_start_timeout

    if [ $# -gt 0 ]; then # followers were provided, so run these endpoint-leader syncs
        do_roadblock "collector-start-tools" "leader" $default_timeout "" $@
    fi
    do_roadblock "client-server-start-tools" "follower" $default_timeout
}

function process_bench_roadblocks() {
    local endpoint_type=""
    if [ $# -eq 1 ]; then
        endpoint_type=$1; shift
    fi
    local timeout=$default_timeout
    local quit=0
    abort_run_on_iter_fail=0
    max_sample_failures=5
    while read -u 9 line; do
        iter_samp=`echo $line | awk '{print $1}'`
        iter=`echo $iter_samp | awk -F- '{print $1}'`
        let iter_idx=$iter-1
        sample_failures[$iter_idx]=0
    done 9< "$client_server_bench_cmds_dir/client/1/start"
    while read -u 9 line; do
        if [ $quit -gt 0 ]; then
            echo "quit = 1, so breaking out of tests"
            break
	    fi
        iter_samp=`echo $line | awk '{print $1}'`
        iter=`echo $iter_samp | awk -F- '{print $1}'`
        let iter_idx=$iter-1
        samp=`echo $iter_samp | awk -F- '{print $2}'`
        iter_samp_dir="$endpoint_run_dir/iteration-$iter/sample-$samp"
        cs_msgs_dir="$iter_samp_dir/msgs"
        cs_tx_msgs_dir="$cs_msgs_dir/tx" # Messages a client, server, or endpoint wants to transmit
        cs_rx_msgs_dir="$cs_msgs_dir/rx" # Messages a client, server, or endpoint has received
        for this_dir in "$iter_samp_dir" "$cs_msgs_dir" "$cs_tx_msgs_dir" "$cs_rx_msgs_dir"; do
            echo "mkdir -p $this_dir"
            mkdir -p "$this_dir" || exit_error "Could not mkdir $this_dir"
        done
        this_attempt_num=1
        sample_complete=0
        while [ $sample_complete -eq 0 -a ${sample_failures[$iter_idx]} -lt $max_sample_failures ]; do
            this_attempt_fail=0
            printf "Sample %d attempt number %d\n" $samp $this_attempt_num
            msgs_json_file=""
            syncs=""
            stop_syncs=""
            for start_stop in "start" "stop"; do
                #for sync in server-start endpoint-start client-start client-stop endpoint-stop server-stop; do
                if [ "$start_stop" == "start" ]; then
                    syncs="server endpoint client"
                else
                    syncs="$stop_syncs"
                fi
                #for sync in server-start endpoint-start client-start client-stop endpoint-stop server-stop; do
                for sync in $syncs; do
                    this_sync="$sync-$start_stop"
                    if [ "$start_stop" == "start" ]; then
                        # Build the syncs needed for stop, may end up being fewer than all syncs if start syncs abort early
                        stop_syncs="$sync $stop_syncs"
                    fi
                    local test_id="test-${iter}-${samp}"
                    local label="${iter}-${samp}-${this_attempt_num}:$this_sync"
                    local msgs_file="$roadblock_msgs_dir/$label.json"
                    do_roadblock "$label" "follower" $timeout "$msgs_json_file"
                    rb_rc=$?
                    echo "roadblock $label exit code: $rb_rc"
                    if [ $rb_rc -eq $rb_exit_abort ]; then
                        this_attempt_fail=1
                        let sample_failures[$iter_idx]=${sample_failures[$iter_idx]}+1
                        echo -e "\nAbort exit code from iteration $iter, sample $samp"
                        if [ ${sample_failures[$iter_idx]} -ge $max_sample_failures ]; then
                            sample_complete=1
                            printf "[ERROR]All A maximum of %d failures for iteration %d have been reached, failing this iteration\n" \
                                $max_sample_failures $iter
                        fi
                        if [ $abort_run_on_iter_fail -eq 1 ]; then
                            printf "[ERROR]Since this interation failed, skipping all other tests\n"
                            quit=1
                        fi
                        if [ "$start_stop" == "start" ]; then
                            # There is no reason to continue the rest of the start syncs
                            break
                        fi
                    else
                        # Allow to break out of inner while loop if no aborts all the way to the last sync
                        if [ $this_attempt_fail -eq 0 ]; then
                            if [ "$this_sync" == "server-stop" ]; then 
                                sample_complete=1
                                let num_fail=$this_attempt_num-1
                                printf "Sample %d completed successfully with %d failed attempts (%d total sample failures for this iteration)\n" \
                                    $samp $num_fail ${sample_failures[$iter_idx]}
                            fi
                        fi
                    fi
	                # Below checks for a specific timeout message from the benchmark client, and all endpoints
	                # process this the same way
                    timeout=$default_timeout
                    if [ -f $msgs_file ]; then
                        next_timeout=`jq -r '.received[] | .payload.message."user-object".timeout ' $msgs_file | grep -v null`
                        if [ ! -z "$next_timeout" ]; then
                            echo "Applying timeout value of $next_timeout to next roadblock sync"
                            timeout=$next_timeout
                        fi
                    fi
	            # The following is organizing any received messages into the $cs_rx_msgs_dir, in case any
	            # specific endpoint wants to read them (via endpoint_${endpoint_type}_test_start() further below)
	            if [ -f $msgs_file ]; then
                        count=1
                        echo "Found messages file: $msgs_file"
                        jq -cr '.received[] | select(.payload.message.command == "user-object") | .payload.message' $msgs_file\
                        | while read line; do
                            msg="$this_sync:$count"
                            echo "Found user-object message: $line"
                            echo "$line" | jq '."user-object"' >"$cs_rx_msgs_dir/$msg"
                            let count=$count+1
                        done
                    fi
	                # This is the opportunity for the endpoints to make any changes
	                # before the actual test starts (client-start).  For example, this
	                # may be used to provide a route to a benchmark-server.  The endpoint
	                # may also create a message to be sent to other participants on
	                # on the next roadblock.
                    if [ ! -z "$endpoint_type" -a "$this_sync" == "endpoint-start" ]; then
		            endpoint_${endpoint_type}_test_start "$roadblock_msgs_dir" "$test_id" "$cs_tx_msgs_dir"
                    fi
                    if [ ! -z "$endpoint_type" -a "$this_sync" == "endpoint-stop" ]; then
		            echo "Attempting to call endpoint_${endpoint_type}_test_stop"
		            endpoint_${endpoint_type}_test_stop "$roadblock_msgs_dir" "$test_id"
                    fi
	                # Check for any messages to send
	                pending_tx_msgs="`/bin/ls -1 $cs_tx_msgs_dir`"
                    if [ ! -z "$pending_tx_msgs" ]; then
                        echo "Found messages in $cs_tx_msgs_dir, preparing them to send"
                        mkdir -p ${cs_tx_msgs_dir}-sent
                        msgs_json_file="$iter_samp_dir/rb-msgs-$this_sync"
                        echo "[" >"$msgs_json_file"
                        for msg in $pending_tx_msgs; do
                            # TODO validate JSON schema
                            echo "Adding $msg to $msgs_json_file"
                            cat "$cs_tx_msgs_dir/$msg" >>"$msgs_json_file"
                            /bin/mv "$cs_tx_msgs_dir/$msg" "${cs_tx_msgs_dir}-sent"
                            echo "," >>"$msgs_json_file"
                        done
                        echo '{"recipient":{"type":"all","id":"all"},"user-object":{"sync":"'$this_sync'"}}]' >>$msgs_json_file
                        echo "full message to send:"
                        cat "$msgs_json_file"
	                else
                        msgs_json_file=""
                    fi
                done #for
            done #for
            let this_attempt_num=$this_attempt_num+1
        done #while
    done 9< "$client_server_bench_cmds_dir/client/1/start"
    # Process the first client's bench-commands to participate in the roadblocks
    # What the start or stop command is not important; we just need to know
    # the number of tests in the right order
}

function process_postbench_roadblocks() {
    for sub_label in stop-tools send-data script-finish; do
        if [ $# -gt 0 ]; then # followers were provided, so run these endpoint-leader syncs
            do_roadblock "collector-$sub_label" "leader" 86400 "" $@
        fi
        do_roadblock "client-server-$sub_label" "follower" $default_timeout
    done
}

function process_final_roadblocks() {
    do_roadblock endpoint-move-data "follower" $endpoint_move_data_timeout
    for label in endpoint-finish endpoint-really-finish; do
        do_roadblock "$label" "follower" $default_timeout
    done
}
