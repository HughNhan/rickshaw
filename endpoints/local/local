#!/usr/bin/env bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash

# This script implements the 'local' endpoint for rickshaw.  It runs 1 or more
# clients and servers for as many benchmark interations/samples as required
# for a single invocation of rickshaw.
# 
# Things that work:
# -validation
# -launching the client/server script in a tmux
#
# Things that don't work or are missing:
# -not using a filesystenm image from workshop
#  -not using a workshop-provided filesystem-image or container-image to either:
#   -use podman to run a container, or
#   -mount the filesystem image (plus /proc & /sys) then chroot to it
#
# Usage:
# local [--validate] --endpoint-opts=client:n-m,o-p,server:n-m,o-p --run-dir --script-dir
#
# If --validate is used all options after client/server will be ignored
# If not using --validate script-dir and --run-dir are required
# The --run-id is rickshaw's run ID
# The --run-dir is rickshaw's current-working-directory,
# The --script-dir is where the client/server scripts are located
# where controller-generated files the endpoint might need will be located

function exit_error() {
    echo "$1"
    exit 1
}

function start_tmux() {
    session_id="$1"
    script="$2"
    if tmux list-sessions 2>/dev/null | awk -F: '{print $1}' | grep -q -- "$session_id"; then
        echo "killing existing tmux session $session_id"
        tmux kill-session -t "$session_id" >/dev/null 2>&1
    fi
    echo "running: tmux new -d -s \"$session_id\" \"$script\""
    tmux new -d -s "$session_id" "$script" 2>&1 "$endpoint_run_dir/>start-tmux.txt"
}

function run_roadblock_follower() {
    local host=$1; shift
    local passwd=$1; shift
    local uuid=$1; shift
    local follower=$1; shift
    if [ -z "$cs_roadblock_opts" ]; then
        return 0
    fi
    /usr/bin/roadblock.py --role=follower --redis-server=$host --timeout=300 --redis-password=$passwd\
              --uuid=$uuid --follower-id=$follower
    return $?
}

endpoint_name="local"
osruntime="builtin" # to be changed to "chroot" when implemented
longopts="validate,endpoint-opts:,run-id:,rickshaw-run-dir:,image-id:,roadblock-server:,roadblock-passwd:,roadblock-id:,osruntime:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    printf -- "\tUnrecognized option specified\n\n"
    exit 1
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --validate)
            do_validate=1
            shift;
            ;;
        --endpoint-opts)
            shift;
            endpoint_opts="$1"
            endpoint_label="$endpoint_name,$endpoint_opts"
            shift;
            ;;
        --run-id)
            shift;
            run_id="$1"
            shift;
            ;;
        --rickshaw-run-dir)
            shift;
            rickshaw_run_dir="$1"
            shift;
            ;;
        --image-id)
            shift;
            image_id="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            roadblock_server="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-server=$roadblock_server"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            roadblock_passwd="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-passwd=$roadblock_passwd"
            shift;
            ;;
        --roadblock-id)
            shift;
            roadblock_id="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-id=$roadblock_id"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
           exit_error "Unexpected argument [$1]"
           shift;
           break;
           ;;
    esac
done

for i in `echo $endpoint_opts | sed -e 's/,/ /g'`; do
    arg=`echo $i | awk -F: '{print $1}'`
    val=`echo $i | awk -F: '{print $2}'`
    case "$arg" in
        client|server|clients|servers)
            for ids in `echo $val | sed -e 's/,/ /'`; do
                if echo $ids | grep -q -- "-"; then
                    range=`echo $ids | sed 's/-/ /'`
                    for j in `seq $range`; do
                        if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                            clients[$j]="client-$j"
                        elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                            servers[$j]="server-$j"
                        fi
                    done
                else
                    if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                        clients[$ids]="client-$ids"
                    elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                        servers[$ids]="server-$ids"
                    fi
                fi
            done
            ;;
        osruntime)
            case "$val" in
                builtin|chroot|podman)
                    osruntime=$val
                    ;;
                *)
                    exit_error "osruntime $val not supported"
                    ;;
            esac
            ;;
        *)
            exit_error "endpoint options $arg not supported"
            ;;
    esac
done

# Validation just returns what clients and servers would be used
if [ "$do_validate" == 1 ]; then
    if [ ${#clients[@]} -gt 0 ]; then
        echo "client ${!clients[@]}"
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "server ${!servers[@]}"
    fi
    exit
fi

if [ -z "$roadblock_server" -o -z "$roadblock_passwd" -o -z "$roadblock_id" ]; then
    echo "Not using roadblock to synchronize since some or all options were missing"
    cs_roadblock_opts=""
    rb_do_exit=0
    if [ ${#clients[@]} -gt 1 ]; then
        echo "Refusing to run because roadblock is not being used and number of clients is > 1"
        rb_do_exit=1
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "Refusing to run because roadblock is not being used and servers are used"
        rb_do_exit=1
    fi
    if [ "$rb_do_exit" == "1" ]; then
        exit_error "Exiting do to roadblock/client/server conflict"
    fi
fi


if [ -z "$run_id" ]; then
    exit_error "The run ID was not provided"
fi
if [ -z "$rickshaw_run_dir" ]; then
    exit_error "--rickshaw-run-dir was not provided"
fi
if [ ! -d "$rickshaw_run_dir" ]; then
    exit_error "The run directory [$rickshaw_run_dir] does not exist"
fi

endpoint_run_dir="$rickshaw_run_dir/endpoint-run/$endpoint_label"
mkdir -p $endpoint_run_dir;
echo osruntime: $osruntime
if [ "$osruntime" == "builtin" ]; then
    # Only the container images already have the client-server-script
    /bin/cp $rickshaw_run_dir/endpoint-run/client-server-script $endpoint_run_dir/client-server-script
    ## below omitted because we will use scp within client-server-script to get the benchmark commands
    #/bin/cp -rL $rickshaw_run_dir/endpoint-run/client-server-commands $endpoint_run_dir
    # All osruntimes need an ssh-key, but for local-endpoint "builtin" it can simply be copied here
    /bin/cp "$rickshaw_run_dir/rickshaw_id.rsa" $endpoint_run_dir
fi
if [ "$osruntime" == "chroot" ]; then
    echo "Adding mount for chroot osruntime"
    container_name=`buildah from --name $endpoint_label $image_id`
    if [ "$container_name" == "$endpoint_label" ]; then
        container_mount=`buildah mount "$container_name"`
        echo "container mount: $container_mount"
        endpoint_run_dir=$container_mount/endpoint-run
        # for chroot osruntime we can also simply copy the ssh key
        /bin/cp "$rickshaw_run_dir/rickshaw_id.rsa" $endpoint_run_dir
        /bin/cp /etc/hosts "$container_mount"
        /bin/cp /etc/resolv.conf "$container_mount"
    fi
fi

# For each client and server launch the actual script which will run it.

#TODO: get rid of below and copy any necessary files (like a fio.job) based on the benchamrk json
pushd $rickshaw_run_dir >/dev/null || exit_error "Could not chdir to $rickshaw_run_dir"
find . -mindepth 1 -maxdepth 1 -type f -print | cpio -pdumv "$endpoint_run_dir" 2>&1 || \
    exit_error "Could not copy files from run dir to $endpoint_run_dir"
popd >/dev/null

for i in ${clients[@]} ${servers[@]}; do
    if [ "$osruntime" == "builtin" ]; then
        cmd="$endpoint_run_dir/client-server-script --rickshaw-host=localhost --rickshaw-run-dir=$rickshaw_run_dir --endpoint-run-dir=$endpoint_run_dir --cs-id=$i $cs_roadblock_opts"
        if [ -e "$endpoint_run_dir/client-server-script" ]; then
            if [ -z "$cs_roadblock_opts" ]; then
                # Only when not using roadblock run the client in the foreground
                echo -e "About to run in foreground:\n$cmd\n"
                $cmd
            else
                echo -e "About to run using tmux:\n$cmd\n"
                start_tmux "$i" "$cmd" || exit_error "Failed to start tmux"
            fi
        else
            echo "[ERROR]could not find script $rickshaw_run_dir/client-server-script"
            exit 1
        fi
    elif [ "$osruntime" == "chroot" ]; then
        echo "using chroot"
        # Note that --endpoint-run value must be hard-coded to /endpoint-run becaue of chroot
        # Same will be true for running podman
        cmd="chroot $container_mount /endpoint-run/client-server-script --rickshaw-host=localhost --rickshaw-run-dir=$rickshaw_run_dir --endpoint-run-dir=/endpoint-run --cs-id=$i $cs_roadblock_opts"
        if [ -z "$cs_roadblock_opts" ]; then
            # Only when not using roadblock run the client in the foreground
            $cmd
        else
            echo -e "About to run using tmux:\n$cmd\n"
            #start_tmux "$i" "$cmd" || exit_error "Failed to start tmux"
            nohup $cmd &
        fi
    elif [ "$osruntime" == "podman"]; then
        echo doing podman runtime
    fi
done

echo "This endpiont deployed"
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" "$roadblock_id:endpoint-deploy" "$endpoint_label"
echo "Waiting for all client/server scripts to finish"
# The next roadblock does not sync until the controller (rickshaw/leader) finishes a "client/server-finish" sync
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" "$roadblock_id:endpoint-move-data" "$endpoint_label"
echo "Moving endpoint data"
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" "$roadblock_id:endpoint-finish" "$endpoint_label"
echo "All endpionts finished"

if [ "$osruntime" == "chroot" ]; then
    echo "Removing mount $container_name for chroot osruntime"
    buildah unmount "$container_name"
    echo "Removing container $container_name for chroot runtime"
    buildah rm "$container_name"
fi
#/bin/rm -rf "$endpoint_run_dir"
# At this point the endpoint is "deployed" and can exit
exit 0


