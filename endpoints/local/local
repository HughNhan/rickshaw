#!/usr/bin/env bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash

# This script implements the 'local' endpoint for rickshaw.  It runs 1 or more
# clients and servers for as many benchmark interations/samples as required
# for a single invocation of rickshaw.
# 
# Things that work:
# -validation
# -launching the client/server script in a tmux
#
# Things that don't work or are missing:
# -not using a filesystenm image from workshop
#  -not using a workshop-provided filesystem-image or container-image to either:
#   -use podman to run a container, or
#   -mount the filesystem image (plus /proc & /sys) then chroot to it
#
# Usage:
# local [--validate] --endpoint-opts=client:n-m,o-p,server:n-m,o-p --run-dir --script-dir
#
# If --validate is used all options after client/server will be ignored
# If not using --validate script-dir and --run-dir are required
# The --run-id is rickshaw's run ID
# The --run-dir is rickshaw's current-working-directory,
# The --script-dir is where the client/server scripts are located
# where controller-generated files the endpoint might need will be located

function exit_error() {
    echo "$1"
    exit 1
}

function start_tmux() {
    session_id="$1"
    script="$2"
    if tmux list-sessions 2>/dev/null | awk -F: '{print $1}' | grep -q -- "$session_id"; then
        echo "killing existing tmux session $session_id"
        tmux kill-session -t "$session_id" >/dev/null 2>&1
    fi
    tmux new -d -s "$session_id" "$script" >start-tmux.txt 2>&1
}

function run_roadblock_follower() {
    local host=$1; shift
    local passwd=$1; shift
    local uuid=$1; shift
    local follower=$1; shift
    if [ -z "$cs_roadblock_opts" ]; then
        return 0
    fi
    roadblock --role=follower --redis-server=$host --timeout=300 --redis-password=$passwd\
              --uuid=$uuid --follower-id=$follower
    return $?
}

endpoint_name="local"
osruntime="builtin" # to be changed to "chroot" when implemented
longopts="validate,endpoint-opts:,run-id:,run-dir:,image-id:,roadblock-server:,roadblock-passwd:,roadblock-id:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    printf -- "\tUnrecognized option specified\n\n"
    usage
    exit 1
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --validate)
            do_validate=1
            shift;
            ;;
        --endpoint-opts)
            shift;
            endpoint_opts="$1"
            shift;
            ;;
        --run-id)
            shift;
            run_id="$1"
            shift;
            ;;
        --run-dir)
            shift;
            run_dir="$1"
            shift;
            ;;
        --image-id)
            shift;
            image_id="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            roadblock_server="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-server=$roadblock_server"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            roadblock_passwd="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-passwd=$roadblock_passwd"
            shift;
            ;;
        --roadblock-id)
            shift;
            roadblock_id="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-id=$roadblock_id"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
           exit_error "Unexpected argument [$1]"
           shift;
           break;
           ;;
    esac
done

for i in `echo $endpoint_opts | sed -e 's/,/ /g'`; do
    arg=`echo $i | awk -F: '{print $1}'`
    val=`echo $i | awk -F: '{print $2}'`
    case "$arg" in
        client|server|clients|servers)
            for ids in `echo $val | sed -e 's/,/ /'`; do
                if echo $ids | grep -q -- "-"; then
                    range=`echo $ids | sed 's/-/ /'`
                    for j in `seq $range`; do
                        if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                            clients[$j]="client-$j"
                        elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                            servers[$j]="server-$j"
                        fi
                    done
                else
                    if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                        clients[$ids]="client-$ids"
                    elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                        servers[$ids]="server-$ids"
                    fi
                fi
            done
            ;;
        osruntime)
            case "$val" in
                builtin|chroot|podman)
                    osruntime=$val
                    ;;
                *)
                    exit_error "osruntime $val not supported"
                    ;;
            esac
            ;;
        *)
            exit_error "endpoint options $arg not supported"
            ;;
    esac
done

# Validation just returns what clients and servers would be used
if [ "$do_validate" == 1 ]; then
    if [ ${#clients[@]} -gt 0 ]; then
        echo "client ${!clients[@]}"
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "server ${!servers[@]}"
    fi
    exit
fi

if [ -z "$roadblock_server" -o -z "$roadblock_passwd" -o -z "$roadblock_id" ]; then
    echo "Not using roadblock to synchronize since some or all options were missing"
    cs_roadblock_opts=""
    rb_do_exit=0
    if [ ${#clients[@]} -gt 1 ]; then
        echo "Refusing to run because roadblock is not being used and number of clients is > 1"
        rb_do_exit=1
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "Refusing to run because roadblock is not being used and servers are used"
        rb_do_exit=1
    fi
    if [ "$rb_do_exit" == "1" ]; then
        exit_error "Exiting do to roadblock/client/server conflict"
    fi
fi


if [ -z "$run_id" ]; then
    exit_error "The run ID was not provided"
fi
if [ -z "$run_dir" ]; then
    exit_error "--run-dir was not provided"
fi
if [ ! -d "$run_dir" ]; then
    exit_error "The run directory [$run_dir] does not exist"
fi

echo osruntime: $osruntime

if [ "$osruntime" == "builtin" ]; then
    cmd_dir="$run_dir/client-server-commands"
    # For each client and server launch the actual script which will run it.
    endpoint_run_dir="$run_dir/endpoint-run/$endpoint_name:$endpoint_opts"
    mkdir -p $endpoint_run_dir;
    for i in ${clients[@]} ${servers[@]}; do
        cs_run_dir="$endpoint_run_dir/$i"
        mkdir -p "$cs_run_dir" || exit_error "Could not create client/server run dir: [$cs_run_dir]"
        echo running $i in $cs_run_dir
        # Below is a HACK.  We should not copy everything from the
        # rickshaw run_dir to the clients/servers
        # We should be using from the bench config JSON, controller.files-to-[client|server]
        pushd $run_dir >/dev/null || exit_error "Could not chdir to $run_dir"
        find . -mindepth 1 -maxdepth 1 -type f -print | cpio -pdumv "$cs_run_dir" >/dev/null 2>&1 || \
            exit_error "Could not copy files from run dir to $i"
        popd >/dev/null
        cmd="$run_dir/client-server-script --rickshaw-host=localhost --run-dir=$run_dir --cs-id=$i --cmd-dir=$cmd_dir $cs_roadblock_opts"
        if [ -e "$run_dir/client-server-script" ]; then
            if [ -e "$cmd_dir/$i" ]; then
                echo "about to start $i: $cmd"
                pushd "$cs_run_dir" >/dev/null ||
                    exit_error "Could not pushd to client/server run dir: [$cs_run_dir]"
                if [ -z "$cs_roadblock_opts" ]; then
                    # Only when not using roadblock run the client in the foreground
                    $cmd
                else
                    echo "using tmux"
                    start_tmux "$i" "$cmd" || exit_error "Failed to start tmux"
                fi
                popd >/dev/null
            else
                echo "[ERROR]could not find command file $cmd_dir/$i"
                exit 1
            fi
        else
            echo "[ERROR]could not find script $run_dir/client-server-script"
            exit 1
        fi
    done
elif [ "$osruntime" == "chroot" ]; then
    echo doing chroot runtime
elif [ "$osruntime" == "podman"]; then
    echo doing podman runtime
fi

echo "This endpiont deployed"
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" "$roadblock_id:endpoint-deploy" "$endpoint_name:$endpoint_opts"
echo "Waiting for all client/server scripts to finish"
# The next roadblock does not sync until the controller (rickshaw/leader) finishes a "client/server-finish" sync
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" "$roadblock_id:endpoint-move-data" "$endpoint_name:$endpoint_opts"
#roadblock --role=follower --redis-server=localhost --timeout=7200 --redis-password=flubber\
          #--uuid=$run_id:endpoint-move-data --follower-id="$endpoint_name:$endpoint_opts"
echo "Moving endpoint data"
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" "$roadblock_id:endpoint-finish" "$endpoint_name:$endpoint_opts"
#roadblock --role=follower --redis-server=localhost --timeout=300 --redis-password=flubber\
          #--uuid=$run_id:endpoint-finish --follower-id="$endpoint_name:$endpoint_opts"
echo "All endpionts finished"
/bin/rm -rf "$endpoint_run_dir"
# At this point the endpoint is "deployed" and can exit
exit 0


