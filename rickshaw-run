#!/usr/bin/perl
# -*- mode: perl; indent-tabs-mode: t; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=perl
#
# Author: Andrew Theurer
#
# Rickshaw will run a benhcmark for you.  Please see README.md for instructions.

use strict;
use warnings;
use Cwd;
use Data::UUID;
use File::pushd;
use File::Basename;
use File::Temp qw(tempdir);
use File::Copy;
use File::Path qw(make_path);
use JSON::XS;
use JSON::Validator;
use Data::Dumper;

my $ug = Data::UUID->new;
my %defaults = ( "num-samples" => 1, "tool-group" => "default", "test-order" => "s",
                 "base-run-dir" => tempdir(), "run-id" => $ug->create_str());

my $userenv = "rhubi8";
my $debug = 0;
my $use_roadblock = 0;
my $use_workshop = 0;
my %bench_config;
my @endpoints;
my %run; # A multi-dimensional, nested hash, schema TBD
         # This hash documents what was run.
my $redis_passwd = "flubber"; # TODO: make this cmdline setting
my $rb_base_uuid = $run{'run-id'};
my $rb_bin = "/usr/local/bin/roadblock.py";
chomp (my $hostname = `hostname`);
my $base_rb_leader_cmd = $rb_bin . " --role=leader --redis-server=localhost --timeout=300" .
                         " --redis-password=" . $redis_passwd;
my $base_rb_follower_cmd = $rb_bin . " --role=follower --redis-server=localhost --timeout=300" .
                           " --redis-password=" . $redis_passwd . "\$abort_opt";
my $rickshaw_project_dir;
my $endpoint_roadblock_opt = "";
my $workshop_roadblock_opt = "";
{
    # Get the absolute path of the rickshaw project directory
    my $pushd_dir = pushd(dirname($0));
    $rickshaw_project_dir = getcwd();
}
my $bench_schema_file = $rickshaw_project_dir . "/schema/benchmark.json";
my $tool_schema_file = $rickshaw_project_dir . "/schema/tool.json";
my $run_schema_file = $rickshaw_project_dir . "/schema/run.json";
my $json_validator = 'json-validator';
my $roadblock_exit_abort = 4;

sub usage {
    print "\nusage:\n\n";
    print "--json-validator Path to json schema validation utility\n";
    print "--workshop-dir   Directory where workshop project exists\n";
    print "--roadblock-dir  Directory where workshop project exists\n";
    print "--bench-dir      Directory where benchmark helper project exists\n";
    print "--bench-params  File with benchmark parameters to use\n";
    print "--tools-dir     Directory where *all* tool subprojects exist (like \$CRUCIBLE_HOME/subprojects/tools)\n";
    print "--tool-params   File with tool parameters to use\n";
    print "--num-samples    The number of sample exeuctions to run for each benchmark iteration\n";
    print "--test-order     's' = run all samples of an iteration first\n";
    print "                 'i' = run all iterations of a sample first\n\n";
}

sub roadblock_leader {
    if ($use_roadblock) {
        my $uuid = shift;
        my $uuid_param = " --leader-id=controller --uuid=" . $run{'run-id'} . ":" . $uuid;
        my $follower_param = "";
        while (scalar @_ > 0) {
            $follower_param .= " --followers=" . shift;
        }
        printf "Running roadblock for: %s\n", $uuid;
        my $cmd = $base_rb_leader_cmd . $uuid_param . $follower_param;
        debug_log(sprintf "roadblock leader command:%s\n", $cmd);
        my $output = `$cmd`;
        my $rc = $? & 127;
        debug_log($output);
        debug_log(sprintf "roadblock exit code: %d\n", $rc);
        # Becasue roadblock leader does not exit with right code
        if ( my $g_output = grep(/(Exiting\swith\sabort|Roadblock\sCompleted\swith\san\sAbort)/, $output) ) {
            printf "Found:\n%s\n", $g_output;
            printf "%s\n", $output;
            $rc = $roadblock_exit_abort;
        }
        if ( my $g_output = grep(/(The\sroadblock\shas\stimed\sout|ERROR:\sRoadblock\sfailed\swith\stimeout)/, $output) ) {
            printf "Found:\n%s\n", $g_output;
            printf "%s\n", $output;
            $rc = 3;
        }
        printf "Completed roadblock for: %s, return code %d\n", $uuid, $rc;
        return $rc;
    } else {
        return 0;
    }
}

sub debug_log {
    if ($debug) {
        print "[DEBUG]" . shift;
    }
}

sub dump_params {
    my $params_ref = shift;
    my $cs_id = shift;
    my $params_str = "";
    foreach my $param (@{ $params_ref }) {
        my $arg = $$param{'arg'}; 
        my $val = $$param{'val'};
        if (defined $cs_id) {
            $val =~ s/\%client-id\%/$cs_id/;
        }
            $params_str .= " --" . $arg . "=" . $val;
    }
    $params_str =~ s/^\s//;
    return $params_str;
}

sub put_json_file {
    my $filename = shift;
    my $json_ref = shift;
    my $schema_filename = shift;
    my $coder = JSON::XS->new->canonical->pretty;
    if (defined $schema_filename and -e $schema_filename) {
        my $jv = JSON::Validator->new;
        open(FH, $schema_filename) or die "Could not open $schema_filename";
        my $json_text;
        while ( <FH> ) {
            $json_text .= $_;
        }
        close FH;
        $jv->schema($json_text);
        debug_log(sprintf "Going to validate schema with [%s]\n", $schema_filename);
        my @errors = $jv->validate($json_ref);
        if (scalar @errors >  0) {
            print "errors:\n" . Dumper \@errors;
            exit 1;
        }
    }
    debug_log(sprintf "trying to write [%s]\n", $filename);
    my $json_text = $coder->encode($json_ref);
    open(JSON_FH, ">" . $filename) || die("Could not open file $filename\n");
    printf JSON_FH "%s", $json_text;
    close JSON_FH;
}

sub get_json_file {
    my $filename = shift;
    my $schema_filename = shift;
    my $coder = JSON::XS->new;
    my $jv = JSON::Validator->new;
    debug_log(sprintf "trying to open [%s]\n", $filename);
    open(FH, $filename) || die("Could not open file $filename\n");
    my $json_text = "";
    while ( <FH> ) {
        $json_text .= $_;
    }
    close FH;
    my $json_ref = $coder->decode($json_text) || die "Could not read JSON";
    if (defined $schema_filename and -e $schema_filename) {
        open(FH, $schema_filename) or die "Could not open $schema_filename";
        my $json_text;
        while ( <FH> ) {
            $json_text .= $_;
        }
        close FH;
        $jv->schema($json_text);
        my @errors = $jv->validate($json_ref);
        print "errors:\n" . Dumper \@errors;
    }
    return $json_ref;
}

sub file_newer_than {
    my $file = shift;
    my $epoch_sec = shift;
    {
        chomp(my $file_time=`/bin/ls -l --time-style=+%s $file`);
        # -rwxrwxr-x. 1 atheurer atheurer 4656 1582742663 client-server-script
        if ($file_time =~ /\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\d+)\s+.*/) {
            if ($1 > $epoch_sec) {
                return 1;
            }
        }
    }
    return 0;
}

sub add_endpoint {
    my $endpoint_ref = shift;
    my $type = shift;
    my $opts = shift;
    my $num = 1;
    for my $entry (@$endpoint_ref) {
        $num++ if ($$entry{'type'} == $type);
    }
    my %endpoint = ( 'type' => $type, 'opts' => $opts, 'label' => $type . "-" . $num);
    push(@$endpoint_ref, \%endpoint);
}

sub dump_endpoint_types {
    my $endpoint_ref = shift;
    my @labels;
    foreach my $endpoint (@$endpoint_ref) {
        push(@labels, $$endpoint{'type'})
    }
    return @labels;
}

sub dump_endpoint_labels {
    my $endpoint_ref = shift;
    my @labels;
    foreach my $endpoint (@$endpoint_ref) {
        push(@labels, $$endpoint{'label'})
    }
    return @labels;
}

sub dir_entries {
    my $dir = shift;
    my $pattern = shift;
    my @entries;
    if (! -e $dir) {
        die "The directory does not exist: $dir";
    }
    opendir(DH, $dir);
    @entries =  readdir(DH);
    if (defined $pattern) {
        @entries =  grep(/$pattern/, @entries);
    }
    close DH;
    return @entries;
}

# Apply envinronment variables
foreach my $e (qw(RS_USER RS_EMAIL RS_TAGS RS_DESC)) {
    if (exists $ENV{$e}) {
        my $var = ($e =~ s/^RS_//);
        $run{$var} = $ENV{$e};
    }
}

# Process the cmdline params
while (scalar @ARGV > 0) {
    my $p = shift @ARGV;
    debug_log(sprintf "processing \@ARGV, param: [%s]\n", $p);
    my $arg;
    my $val;

    if ( $p =~ /^\-\-(\S+)/ ) {
        $arg = $1;
        if ( $arg =~ /^(\S+)=(.*)/ ) { # '--arg=val'
            $arg = $1;
            $val = $2;
        } else { # '--arg val'
            $val = shift @ARGV;
        }
    } else {
        print "[ERROR]malformed cmdline parameter: %s\n";
        usage;
        exit 1;
    }
    debug_log(sprintf "processing \@ARGV, arg is: [%s], val is: [%s]\n", $arg, $val);
    if ($arg eq "endpoint") {
        if ($val =~ /^(\w+),(.*)$/) {
            add_endpoint(\@endpoints, $1, $2);
        } else {
            printf "[ERROR]format for --endpoint is not valid: [%s]\n", $arg;
        }
    } elsif ($arg =~ /^debug$/) {
        $debug = $val;
    } elsif ($arg =~ /^help$/) {
        usage;
        exit 0;
    } elsif ($arg =~ /^json-validator$/) {
        $json_validator = $val;
    } elsif ($arg =~ /^base-run-dir$|^workshop-dir$|^bench-dir$|^roadblock-dir$|^tools-dir$/ or
             $arg =~ /^run-id$|^bench-params$|^tool-params$|^bench-params$/ or
             $arg =~ /^test-order$|^tool-group$|^num-samples$|^name$/ or
             $arg =~ /^email$|^tags$|^desc$/) {
        debug_log(sprintf "argument: [%s]\n", $arg);
        $run{$arg} = $val;
    } else {
        printf "[ERROR]argument not valid: [%s]\n", $arg;
        usage;
        exit 1;
    }
}

system($json_validator . " --help >/dev/null");
if ($? != 0) {
    printf "json-validator: %s does not work, exiting\n", $json_validator;
    exit 1;
}
if (defined $run{'roadblock-dir'} and -e $run{'roadblock-dir'} . "/roadblock.py") {
    copy($run{'roadblock-dir'} . "/roadblock.py", $rb_bin);
    chmod 0755, "$rb_bin";
    $use_roadblock = 1;
}
if (defined $run{'workshop-dir'} and -e $run{'workshop-dir'} . "/workshop.pl") {
    $use_workshop = 1;
}

# Load the bench config and user params
exists $run{'bench-dir'} || die "[ERROR]You must use --bench-dir=/path/to/benchmark-subproject\n";
my $bench_config_file = $run{'bench-dir'} . "/rickshaw.json";
if (-e $bench_config_file) {
    my $bench_config_ref = get_json_file($bench_config_file, $bench_schema_file);
    %bench_config = %{ $bench_config_ref };
    if (exists $bench_config{'benchmark'}) {
        printf "Preparing to run %s\n", $bench_config{'benchmark'};
        $run{'benchmark'} = $bench_config{'benchmark'};
    } else {
        print "[ERROR]benchmark was not defined in %s\n", $bench_config_file;
        exit 1;
    }
} else {
    printf "[ERROR]benchmark subproject config file %s was not found\n", $bench_config_file;
    exit 1;
}
exists $run{'bench-params'} || die "[ERROR}You must use " .
                                   "--bench-params=/path/to/benchmark-params.json\n";
my @param_sets = @{ my $param_sets_ref = get_json_file($run{'bench-params'}) };
# TODO: verify user params schema
$run{'iterations'} = ();
my $iter_id = 0;
for my $params (@param_sets) {
    $run{'iterations'}[$iter_id]{'params'} = $params;
    $iter_id++;
}

exists $run{'tools-dir'} || die "[ERROR]You must use " . 
                                "--tools-dir=/path/to/tools/base/subproject-dir " .
                                "(\$CRUCIBLE_HOME/subprojects/tools)\n";
# Load the default tool params
if (not exists $run{'tool-params'} ) {
    $run{'tool-params'} = $rickshaw_project_dir . "/config/tools.json";
}
my @tools_params = @{ my $json_ref = get_json_file($run{'tool-params'}) };
my %tools_configs;
# Load a tool configuration for every tool the user is asking for
foreach my $tool_entry (@tools_params) {
    my $this_tool_config = $run{'tools-dir'} . "/" . $$tool_entry{'tool'} . "/rickshaw.json";
    my $json_ref = get_json_file($this_tool_config, $tool_schema_file);
    $tools_configs{$$json_ref{'tool'}} = $json_ref;
}

# Apply defaults
foreach my $p (keys %defaults) {
    if (! exists $run{$p}) {
        debug_log(sprintf "applying default value [%s] for %s\n", $defaults{$p}, $p);
        $run{$p} = $defaults{$p};
    }
}

# Ensure the bench-dir, base-run-dir, and tools-dir have absolute paths
# because they may be referenced by clients and servers later
for my $dirtype (qw(base-run-dir bench-dir tools-dir)) {
    {
        my $pushd_dir = pushd($run{$dirtype});
        debug_log(sprintf "pushd to [%s]\n", $run{$dirtype});
        my $cwd = getcwd();
        debug_log(sprintf "cwd [%s]\n", $cwd);
        $run{$dirtype} = $cwd;
    }
}
-e $run{'base-run-dir'} || mkdir($run{'base-run-dir'});
printf "Base run directory: [%s]\n", $run{'base-run-dir'};
printf "Bench helper subproject directory: [%s]\n", $run{'bench-dir'};
my $config_dir = $run{'base-run-dir'} . "/config";
mkdir($config_dir);
my $client_server_config_dir = $config_dir . "/client-server";
mkdir($client_server_config_dir);
my $client_server_bench_cmds_dir = $client_server_config_dir . "/bench-cmds";
mkdir($client_server_bench_cmds_dir);
my $tool_cmds_dir = $config_dir . "/tool-cmds";
mkdir($tool_cmds_dir);
my $run_dir = $run{'base-run-dir'} . "/run";
mkdir($run_dir);
my $base_endpoint_run_dir = $run_dir . "/endpoint/";
mkdir($base_endpoint_run_dir);
my $client_server_run_dir = $run_dir . "/client-server/";
mkdir($client_server_run_dir);
my $client_server_logs_dir = $client_server_run_dir . "/logs/";
mkdir($client_server_logs_dir);
my $client_server_archives_dir = $client_server_run_dir . "/archives/";
mkdir($client_server_archives_dir);
my $client_server_run_script = $client_server_config_dir . "/client-server-script";
my $iterations_dir = $run_dir . "/iterations";
mkdir($iterations_dir);

# If there are no endpoints, assume 1 endpoint using the 'local' extension
if (scalar @endpoints == 0) {
    if (exists $bench_config{'client'} and exists $bench_config{'server'}) {
        add_endpoint(\@endpoints, "local", "client[1],server[1]");
    } else {
        add_endpoint(\@endpoints, "local", "client[1]");
    }
}

# Call each endpoint script with "--validate" as the first option, and each endpoint script should
# return a list of clients and servers which are used from this endpoint.  Collect this output
# and verify there are no gaps in the numbering of clients, and if the benchmark uses servers,
# that there is 1 server for every client.
# Why can't we just parse the endpoint option?  Because there is no gaurantee that the endpoint
# option always contains the client and server IDs that will be used.  For example, an endpoint
# for k8s might look like: "--endpoint:[1-5]" where client and server are not required, and when
# not used, this endpoint assumes both clients and servers (for IDs 1-5) will be deployed. 
# This ensures the format of the specific endpoint option string is completely up to that endpoint
# and not rickshaw.
my %clients_servers;
my @rb_cs_ids; # unique IDs for roadblock
my $min_id;
my $max_id;
printf "Confirming the endpoints will satisfy the benchmark-client ";
printf "and benchmark-server " if exists $bench_config{'server'};
printf "requirements\n";
foreach my $endpoint (@endpoints) {
    my $pushd_dir = pushd("./endpoints/" . $$endpoint{'type'});
    my $cmd = "./" . $$endpoint{'type'} .
              " --endpoint-opts=" . $$endpoint{'opts'} .
              " --validate";
    debug_log(sprintf "endopoint validation command: [%s]\n", $cmd);
    my @output = grep(!/^#/, `$cmd`);
    if ($? > 0) {
        die "[ERROR]Endpoint " . $$endpoint{'type'} . " with options " . $$endpoint{'opts'} .
            " validation returned non-zero exit code:\n" . join("\n", @output);
    }
    # Output from endpoint's validation should be 1 or more lines with "client" or "server"
    # followed by 1 or more positive integers representing the client/server IDs this
    # endpoint handles::
    # client <int> [int]
    # server <int> [int]
    foreach my $line (@output) {
        chomp $line;
        if ($line =~ /(client|server)\s+(.+)$/) {
            my $client_server = $1;
            my $ids = $2;
            foreach my $id (split(/\s+/, $ids)) {
                die "[ERROR]client/server ID cannot be below 1\n" if ($id < 1);
                my %info = ( 'endpoint-type' => $$endpoint{'type'}, 'id' => $id );
                $clients_servers{$client_server}[$id - 1] = \%info;
                push(@rb_cs_ids, $client_server . "-" . $id);
                $min_id = $id if (! defined $min_id or $id < $min_id);
                $max_id = $id if (! defined $max_id or $id > $max_id);
            }
        } else {
            printf "[ERROR]output from endpoint validation incorrect:\n%s\n", $line;
            exit 1;
        }
    }
}
if ($min_id != 1) {
    printf "[ERROR]lowest ID found in clients and servers is %d, must be 1\n", $min_id;
    exit 1;
}
for (my $id = $min_id; $id <= $max_id; $id++) {
    debug_log(sprintf "checking for client ID %d\n", $id);
    if (! defined $clients_servers{'client'}[$id - 1]) {
        printf "[ERROR]client ID %d is not defined in ID range %d - %d\n", $id, $min_id, $max_id;
        exit 1;
    }
    if (exists $bench_config{'server'}) {
        debug_log(sprintf "checking for server ID %d\n", $id);
        if (! defined $clients_servers{'server'}[$id - 1]) {
            printf "[ERROR]server ID %d is not defined in ID range %d - %d\n",
                   $id, $min_id, $max_id;
            exit 1;
        }
    } else {
        debug_log(sprintf "checking for no server IDs\n");
        if (defined $clients_servers{'server'}[$id - 1]) {
            printf "[ERROR]server ID %d is defined in ID range %d - %d, but this benchmark " .
                   "does not use servers\n", $id, $min_id, $max_id;
            exit 1;
        }
    }
}
printf "There will be %d client(s)", $max_id;
printf " and server(s)" if exists $bench_config{'server'};
printf "\n";

if ($use_roadblock) {
    $endpoint_roadblock_opt = " --roadblock-server=" . $hostname .
                              " --roadblock-id=" . $run{'run-id'} .
                              " --roadblock-passwd=" . $redis_passwd;
    $workshop_roadblock_opt = " --requirements " . $run{'roadblock-dir'} .
                              "/workshop.json ";
} else {
    # If for some reason the user has opted to not use roadblock, then only allow
    # tests which use only one client and no server, which is the only possible
    # combination we can support without syncronization
    my $do_exit = 0;
    if (scalar @{ $clients_servers{'server'} } > 0) {
        printf "[ERROR}since --roadblock-dir was not used or the directory does not exist," .
               "rickshaw cannot run a test with servers because it cannot syncornize the test " .
               "without roadblock.\n";
               $do_exit = 1;
    }
    if (scalar @{ $clients_servers{'client'} } > 1) {
        printf "[ERROR}since --roadblock-dir was not used or the directory does not exist," .
               "rickshaw cannot run a test with multiple clients because it cannot synchronize " .
               "the test without roadblock.\n";
               $do_exit = 1;
    }
    if ($do_exit) {
        exit 1;
    }
}


$run{'endpoints'} = \@endpoints;

printf "Building test execution order\n";
# Build test execution order (and the iteration/sample dirs)
my @tests;
if ($run{'test-order'} eq 's') {
    for (my $iid = 1; $iid <= scalar @{ $run{'iterations'} }; $iid++) {
        for (my $sid = 1; $sid <= $run{'num-samples'}; $sid++) {
            my %test = ('iteration-id' => $iid, 'sample-id' => $sid);
            push(@tests, \%test);
        }
    }
} elsif ($run{'test-order'} eq 'i') {
    for (my $sid = 1; $sid <= $run{'num-samples'}; $sid++) {
        for (my $iid = 1; $iid <= scalar @{ $run{'iterations'} }; $iid++) {
            my %test = ('iteration-id' => $iid, 'sample-id' => $sid);
            push(@tests, \%test);
        }
    }
} else {
    printf "[ERROR]Value for --test-order [%s] is not valid\n", $run{'test-order'};
    usage;
    exit 1;
}

# Run on the controller (the host running this script) the benchmark-specific "pre-script"
if (exists $bench_config{"controller"}{"pre-script"} and $bench_config{"controller"}{"pre-script"} ne "") {
    my $pushd_dir = pushd($run_dir);
    # Note that the user params for the benchmark are from the first set only
    # This pre-script is run only once before all of the tests are started.
    # If this script generates a file to aid in benchmark execution (such as a job file),
    # The file should work for all perams sets (all benchmark iterations).  If you need
    # different job files per iteration, then use the client or server-side "pre-script"
    # to either augment a file generated here or create a completely new file.
    my $cmd = $bench_config{"controller"}{"pre-script"} . " " . dump_params($run{'iterations'}[0]{'params'});
    $cmd =~ s/\%bench-dir\%/$run{'bench-dir'}/g;
    $cmd =~ s/\%run-dir\%/$run_dir/g;
    debug_log(sprintf "controller pre-script command: [%s]\n", $cmd);
    my $pre_cmd_output = `$cmd . '2>&1'`;
    debug_log(sprintf "controller pre-script output:\n%s\n", $pre_cmd_output);
}

copy($rickshaw_project_dir . "/client-server-script", $client_server_run_script)
    || die "Could not copy client-server-script to " . $client_server_run_script .
           "/client-server-script";
chmod 0755, "$client_server_run_script";
# Each tool may specify, for specific endpoints, that it needs to run somewhere other than a client
# or server (a "collector").  This preference is in the "whitelist" section.  Check each tool used
# to see if we need to build a command file for any of these collectors.
my %collectors;
foreach my $tool_entry (@tools_params) {
    my $tool_name = $$tool_entry{'tool'};
    if (exists $tools_configs{$tool_name}{'collector'}{'whitelist'}) {
        for my $i (@{ $tools_configs{$tool_name}{'collector'}{'whitelist'} }) {
            my $endpoint = $$i{'endpoint'};
            # Does this endpoint in tool config match one of th endpoints used for this run?
            if (grep(/^$endpoint$/, dump_endpoint_types(\@endpoints))) {
                # Then add this tool to the list of tools for this collector
                for my $collector (@{ $$i{'collector-types'} }) {
                    if (! exists($collectors{$collector})) {
                        $collectors{$collector} = ();
                    }
                    push(@{ $collectors{$collector} }, $tool_name);
                }
            }
        }
    }
}
# Now build all of the tool start and stop cmd files for each collector
for my $collector (keys %collectors) {
    for my $start_stop ("start", "stop") {
        my $collector_tool_cmds_dir = $tool_cmds_dir . "/" . $collector;
        -e $collector_tool_cmds_dir || make_path($collector_tool_cmds_dir) ||
            die "[ERROR]Create collector directory failed: [" . $collector_tool_cmds_dir . "]\n";
        my $tool_cmd_file = $collector_tool_cmds_dir . "/" . $start_stop; 
        open(TOOL_CMD_FH, ">" . $tool_cmd_file) ||
            die "[ERROR]could not open cmd file for writing: [" . $tool_cmd_file . "]\n";
        debug_log(sprintf "writing tool-cmds [%s]\n", $tool_cmd_file);
        foreach my $tool_entry (@tools_params) {
            my $tool_name = $$tool_entry{'tool'};
            if (grep($tool_name, @{ $collectors{$collector} })) {
                my $tool_cmd = $tool_name . ": " . $tools_configs{$tool_name}{'collector'}{$start_stop};
                foreach my $tool_param (@{ $$tool_entry{'params'} }) {
                    $tool_cmd .= " --" . $$tool_param{'arg'} . " " . $$tool_param{'val'};
                }
                printf TOOL_CMD_FH "%s\n", $tool_cmd;
            }
        }
        close(TOOL_CMD_FILE);
        chmod 0755, $tool_cmd_file;
    }
}
# By default all tools run on client and servers.  However,
# in some cases tools should not be run in the client or server, either
# because there is nothing to collect in that runtime, or the tool is
# already collecting that data from a different source (and a client
# and/or server would be collecting duplicate data).  For this reason tool
# cmd files are built specifically for each client and server.
foreach my $cs_type (keys %clients_servers) {
    for my $start_stop ("start", "stop") {
        foreach my $cs_ref (@{ $clients_servers{$cs_type} }) {
            my $cs_tool_cmds_dir = $tool_cmds_dir . "/" . $cs_type . "/" . $$cs_ref{'id'};
            make_path($cs_tool_cmds_dir);
            my $tool_cmd_file = $cs_tool_cmds_dir . "/" . $start_stop;
            open(TOOL_CMD_FH, ">" . $tool_cmd_file) ||
                die "[ERROR]could not open cmd file for writing: [" . $tool_cmd_file . "]\n";
            my $cs_endpoint = $$cs_ref{'endpoint-type'};
            foreach my $tool_entry (@tools_params) {
                my $tool_name = $$tool_entry{'tool'};
                my $tool_cmd = $tool_name . ": " . $tools_configs{$tool_name}{'collector'}{$start_stop};
                foreach my $tool_param (@{ $$tool_entry{'params'} }) {
                    $tool_cmd .= " --" . $$tool_param{'arg'} . " " . $$tool_param{'val'};
                }
                # Check if the client/server is deployed by an endpoint that blacklists this tool 
                if (exists $tools_configs{$tool_name}{'collector'}{'blacklist'}) {
                    for my $i (@{ $tools_configs{$tool_name}{'collector'}{'blacklist'} }) {
                        if ($$cs_ref{'endpoint-type'} eq $$i{'endpoint'}) {
                            # If it is, don't let this client/server run this tool
                            debug_log(sprintf "%s %d will not run tool %s\n",
                                              $cs_type, $$cs_ref{'id'}, $tool_name);
                            undef $tool_cmd;
                        }
                    }
                }
                if (defined $tool_cmd) {
                    printf TOOL_CMD_FH "%s\n", $tool_cmd;
                }
            }
            close(TOOL_CMD_FH);
        }
    }
}

# Build the client and server bench-cmd files
foreach my $cs_type (keys %clients_servers) {
    foreach my $cs_ref (@{ $clients_servers{$cs_type} }) {
        my @cmd_type_files = ("start");
        if ($cs_type eq "server") {
            push(@cmd_type_files, "stop");
        }
        my $cs_id = $$cs_ref{'id'};
        my $this_cmds_dir = $client_server_bench_cmds_dir . "/" . $cs_type . "/" . $cs_id;
        make_path($this_cmds_dir) || die "Could not mkdir " . $this_cmds_dir;
        foreach my $cmd_type (@cmd_type_files) {
            my $this_cmd_file = $this_cmds_dir . "/" . $cmd_type;
            open(FH, ">" . $this_cmd_file) ||
                die "[ERROR]Open bench-cmds file for writing failed: [" . $this_cmd_file . "]\n";
            debug_log(sprintf "writing bench-cmds [%s]\n", $this_cmd_file);
            foreach my $test_ref (@tests) {
                my $test_iter = $$test_ref{'iteration-id'};
                my $test_samp = $$test_ref{'sample-id'};
                my $iter_array_idx = $test_iter - 1;
                if (exists $bench_config{$cs_type}{$cmd_type} and
                    $bench_config{$cs_type}{$cmd_type} ne "") {
                    my $cmd = $bench_config{$cs_type}{$cmd_type} . " " .
                            dump_params($run{'iterations'}[$iter_array_idx]{'params'}, $cs_id);
                    debug_log(sprintf "cmd: [%s]\n", $cmd);
                    # Apply a regex from the benchmark config file to the command
                    # This is used to remove things like "--clients=" because the
                    # native benchmark does not understand this parameter
                    if ($bench_config{$cs_type} and $bench_config{$cs_type}{"param_regex"}) {
                        for my $r (@{ $bench_config{$cs_type}{"param_regex"} }) {
                            # to apply the 's/x/y/' regex from the file, some eval trickery is necessary
                            # todo: first test the $r regex separately for [perl syntax] errors with eval
                            # before doing below
                            $cmd = eval "\$_='$cmd'; $r; return scalar \$_";
                        }
                    }
                    printf FH "%d-%d %s\n", $test_iter, $test_samp, $cmd;
                } else {
                    die "[ERROR]Could not find " . $cmd_type . " in bench_config\n";
                }
            }
            close FH;
            chmod 0755, $this_cmd_file;
        }
    }
}

# Build the client/server "from-controller" files list and put them in the base endpoint run dir.
# These are files the client/server must copy from the controller before running any tests.
# The "client-server-script" will first scp the list (client-files-list or server-files-list).
# then it will read this list to know what other files to copy over)
#
# TODO: build these files for other collectors
foreach my $cs_type (keys %clients_servers, keys %collectors) {
    my $cs_file_list = $client_server_config_dir . "/" . $cs_type . "-files-list";
    open(FH, ">" . $cs_file_list) || die "[ERROR]could not open " . $cs_file_list . " for writing";
    if ($cs_type =~ /(client|server)/ and exists $bench_config{$cs_type}{"files-from-controller"}) {
        for my $file_spec (@{ $bench_config{$cs_type}{"files-from-controller"} } ) {
            my $src_file = $$file_spec{'src'};
            $src_file =~ s/\%bench-dir\%/$run{'bench-dir'}\//g;
            $src_file =~ s/\%run-dir\%/$run_dir\//g;
            $src_file =~ s/\%config-dir\%/$config_dir\//g;
            my $dest_file = $$file_spec{'dest'};
            printf FH "src=%s\ndest=%s\n", $src_file, $dest_file;
        }
    }
    foreach my $tool_entry (@tools_params) {
        my $tool_name = $$tool_entry{'tool'};
        if (exists $tools_configs{$tool_name}{'collector'}{'files-from-controller'}) {
            for my $file_spec (@{ $tools_configs{$tool_name}{'collector'}{"files-from-controller"} } ) {
                my $src_file = $$file_spec{'src'};
                $src_file =~ s/\%tool-dir\%/$run{'tools-dir'}\/$$tool_entry{'tool'}\//g;
                $src_file =~ s/\%run-dir\%/$run_dir\//g;
                $src_file =~ s/\%config-dir\%/$config_dir\//g;
                my $dest_file = $$file_spec{'dest'};
                printf FH "src=%s\ndest=%s\n", $src_file, $dest_file;
            }
        }
    }
    close FH;
}

# Build a new container image if one does not exist or is stale
my $endpoint_image_opt = "";
if ($use_workshop) {
    my $image_id;
    # First determine if we need to build a new image
    my $must_rebuild = 0;
    my $image_time;
    my $image_name = "workshop/" . $userenv . "_" . $run{'benchmark'};
    my $image_json = `buildah  images --json`;
    my $coder = JSON::XS->new;
    my $image_json_ref = $coder->decode($image_json);
    my $image_found = 0;
    my @newer_files;
    for (my $i=0; $i< scalar @$image_json_ref ; $i++) {
        if (exists $$image_json_ref[$i]{'names'}[0]) {
            my $name = $$image_json_ref[$i]{'names'}[0];
            printf "name: [%s]\n", $name;
            $name =~ s/[^\/]+\///;
            $name =~ s/:.*//;
            printf "Comparing [%s] to [%s]\n", $image_name, $name;
            if ($name eq $image_name) {
                print "Found existing image\n";
                $image_found = 1;
                $image_id = $$image_json_ref[$i]{'id'};
                $image_time = $$image_json_ref[$i]{'createdatraw'};
                $image_time = `date -d $image_time +%s`;
                my @files = ($run{'bench-dir'} . "/workshop.json",
                            $run{'workshop-dir'} . "/userenvs/" . $userenv . ".json",
                            $rickshaw_project_dir . "/client-server-script");
                foreach my $tool_entry (@tools_params) {
                    push(@files, $run{'tools-dir'} . "/" . $$tool_entry{'tool'} . "/workshop.json");
                }
                for my $file (@files) {
                    if ( file_newer_than($file, $image_time) > 0) {
                        printf "%s is newer than the container image\n", $file;
                        push(@newer_files, $file);
                        $must_rebuild = 1;
                    }
                }
            }
        }
    }
    if ($must_rebuild or !$image_found) {
        printf "The container image must be rebuilt because:\n";
        if (!$image_found) {
            printf "* the existing container image name [%s] was not found\n", $image_name;
        }
        if ($must_rebuild) {
            printf "* the container image is older than a file that goes in it:\n%s",
                   join('\n', @newer_files);
        }
        # Build a container image for the clients/servers
        # Create a json which tells workshop to include these files:
        # - the client-server-script (which has logic to execute all tests)
        # - the roadblock client script (which the client-server-script uses)
        #
        # We want to avoid adding content to the image that changes
        # with each invocation of rickshaw because we want to cache
        # these images [eventually].  So, we should not include anything
        # like "client-server-commands" because this changes every time
        # rickshaw is run.
        my $cs_req_file = $config_dir . "/cs-req.json";
        my %cs_req = (  'workshop' => {
                            'schema' => {
                                'version' => '2020.03.02'
                            }
                        },
                        'userenvs' => [
                            {
                                'name' => 'default',
                                'requirements' => [ 'endpoint-run' ]
                            }
                        ],
                        'requirements' => [
                            {
                                'name' => 'endpoint-run',
                                'type' => 'files',
                                'files_info' => {
                                    'files' => [
                                        {
                                            'src' => $client_server_run_script,
                                            'dst' => '/usr/local/bin'
                                        }
                                    ]
                                }
                            }
                        ] 
                    );
        if ($use_roadblock) {
            my %rb_req = (  'name' => 'roadblock-client',
                            'type' => 'files',
                            'files_info' => {
                                'files' => [
                                    {
                                        'src' => $run{'roadblock-dir'} . "/roadblock.py",
                                        'dst' => '/usr/local/bin/'
                                    }
                                ] 
                            }
                        );
            push(@{ $cs_req{'requirements'} }, \%rb_req);
            push(@{ $cs_req{'userenvs'}[0]{'requirements'} }, "roadblock-client");
        }
        put_json_file($cs_req_file, \%cs_req);
        # Building an image must include requiremetns from rickshaw, one benchmark,
        # and optionally one or more tools and roadblock.
        # TODO: only build when existing image is not found in registry
        my $workshop_cmd = $run{'workshop-dir'} . "/workshop.pl" .
                        " --label " . $run{'benchmark'} .
                        " --userenv " . $run{'workshop-dir'} . "/userenvs/" . $userenv . ".json" .
                        " --requirements " . $run{'bench-dir'} . "/workshop.json" .
                        " --requirements " . $cs_req_file .
                        " --json-validator " . $json_validator .
                        $workshop_roadblock_opt; 
        foreach my $tool_entry (@tools_params) {
            $workshop_cmd .= " --requirements " . $run{'tools-dir'} . "/" .
                             $$tool_entry{'tool'} . "/workshop.json ";
        }
        printf "workshop cmd: %s\n", $workshop_cmd;
        my @workshop_output = `$workshop_cmd`;
        print join("", @workshop_output);
        # Becasue there can be a lot of non-JSON debug/info stuff in the output before the
        # actual JSON, find the JSON by starting at the end and scanning backwards
        my $workshop_json = "";
        for (my $i = scalar @workshop_output - 1; $i > 0; $i--) {
            $workshop_json = $workshop_output[$i] . $workshop_json;
            # Break out if we found all of the JSON
            # In this case the JSON begins with an array '['
            last if ($workshop_output[$i] eq "[\n");
        }
        my $coder = JSON::XS->new;
        my $workshop_ref = $coder->decode($workshop_json);
        $image_id = $$workshop_ref[0]{'id'};
    }
    $endpoint_image_opt = " --image-id=" . $image_id;
    printf "workshop image id: %s\n", $image_id;
}

# Create temporary ssh keys so endpoint clients/servers can pull/push data
my $keygen_cmd = 'ssh-keygen -f ' . $config_dir . '/rickshaw_id.rsa -P "" 2>&1';
my $keygen_output = `$keygen_cmd`;
system('cat ' . $config_dir . '/rickshaw_id.rsa.pub >>/root/.ssh/authorized_keys');

# Deploy ths endpoints so they are ready to run benchmark and tools.
# Each endpoint is responible for launching a osruntime for each client and server.
print "Deploying endpoints\n";
debug_log(sprintf "\nendpoint output:\n");
for (my $i = 0; $i < scalar @endpoints; $i++) {
    my $type = $endpoints[$i]{'type'};
    my $opts = $endpoints[$i]{'opts'};
    my $label = $endpoints[$i]{'label'};
    my $this_endpoint_run_dir = $base_endpoint_run_dir . "/" . $label;
    mkdir($this_endpoint_run_dir);
    die "Could not create $this_endpoint_run_dir" if ! -e $this_endpoint_run_dir;
    my $endpoint_project_dir = $rickshaw_project_dir . "/endpoints/" . $type;
    if (-e $endpoint_project_dir) {
        my $pushd_dir = pushd($endpoint_project_dir);
        my $cmd = "./" . $type .
                  " --endpoint-opts=" . $opts .
                  " --endpoint-label=" . $label .
                  " --run-id=" . $run{'run-id'} .
                  " --base-run-dir=" . $run{'base-run-dir'} .
                  $endpoint_image_opt .
                  $endpoint_roadblock_opt .
                  " >" . $this_endpoint_run_dir . "/endpoint-stdout.txt" .
                  " 2>" . $this_endpoint_run_dir . "/endpoint-stderr.txt";
        # The below 'system' needs to be forked, then wait for all to finish.
        # The endpoint program should get all clients/servers "ready", that is,
        # waiting for instructions from roadblock.  The above command needs
        # info about how to contact roadblock.
        # Endpoints should return for each client and server started:
        # - the ID of the client/server
        # - the roadblock client ID
        printf "Going to run endpoint command:\n%s\n\n", $cmd;
        if ($endpoint_roadblock_opt eq "") {
            # There is only one client and no synchronization, so we wait for the endpoint to finish
            debug_log(sprintf "going to run and wait for: %s\n", $cmd);
            #system($cmd);
        } else {
            #debug_log(sprintf "going to run %s\n", $cmd);
            system($cmd . " &");
        }
    } else {
        printf "[ERROR]could not find endpoint ./endpoints/%s\n", $type;
        exit 1;
    }
}
if (roadblock_leader("endpoint-deploy", dump_endpoint_labels(\@endpoints)) > 0) {
    printf "[ERROR]roadblock failed\n";
    exit 1;
}

# Cycle through the list of tests using roadblock to kick them off
for my $sync (qw(client-server-script-start client-server-start-tools)) {
    if (roadblock_leader($sync, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) > 0) {
        printf "[ERROR]roadblock failed, exiting\n";
        exit 1;
    }
}
my $abort_test_id;
for (my $tid = 0; $tid < scalar @tests; $tid++) {
    my $iter_id = $tests[$tid]{'iteration-id'};
    my $samp_id = $tests[$tid]{'sample-id'};
    my $iter_array_idx = $iter_id - 1;
    my $test_id = $iter_id . "-" . $samp_id;
    for my $sync_point (qw(server-start client-start client-stop server-stop)) {
        my $rc = roadblock_leader("test-" . $test_id . ":" . $sync_point, (@rb_cs_ids, dump_endpoint_labels(\@endpoints)));
        if ($rc > 0) {
            if ($rc == $roadblock_exit_abort) {
                printf "[ERROR]Abort from %s so breaking out of test-loop\n", $sync_point;
                $abort_test_id = $tid;
                $tid = scalar @tests; # Force break from outer loop
                last;
            } else {
                printf "[ERROR]roadblock for %s failed, exiting\n", $sync_point;
                exit 1;
            }
        }
    }
}
for my $sync (qw(client-server-stop-tools client-server-send-data client-server-script-finish)) {
    if (roadblock_leader($sync, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) > 0) {
        printf "[ERROR]roadblock failed, exiting\n";
        exit 1;
    }
}
for my $sync (qw(endpoint-move-data endpoint-finish endpoint-really-finish)) {
    if (roadblock_leader($sync, dump_endpoint_labels(\@endpoints)) > 0) {
        printf "[ERROR]roadblock failed, exiting\n";
        exit 1;
    }
}


# With all tests completed, launch the benchmark-specific post-processing script
# for each client and server and each test they ran.
if (defined $abort_test_id) {
    printf "Run finished with only %d of %d tests\n", $abort_test_id, scalar @tests;
    printf "Will not post-process benchmark data\n";
} else {
    print "Post-processing data\n";
    # Organize the data from the clients into a common directory structure, organized by
    # iteration, then by sample, then finally by client/server.  This is needed to have
    # the benchmark's postprocessing script work.  Also background the post-process script
    # for each test and wait for them to complete.
    my $pp_cmd = $bench_config{'controller'}{'post-script'};
    $pp_cmd =~ s/\%bench-dir\%/$run{'bench-dir'}\//g;
    $pp_cmd =~ s/\%run-dir\%/$run_dir\//g;
    $pp_cmd =~ s/\%config-dir\%/$config_dir\//g;
    my @pids;
    my $tmp_data_dir = $run_dir . "/tmp-data-dir";
    {
        mkdir($tmp_data_dir);
        my $pushd_dir = pushd($tmp_data_dir);
        foreach my $archive (dir_entries($client_server_archives_dir,
                                         qr/^(\w+)-(\d+)-data\.tgz$/)) {
            $archive =~ /^(\w+)-(\d+)-data\.tgz$/ or next;
            my $archive_full_path = $client_server_archives_dir . "/" . $archive;
            my $cs_type = $1;
            my $cs_id = $2;
            my $tar_cmd = "tar zxf " . $archive_full_path;
            my $tar_output = `$tar_cmd`;
            if ($1 =~ /^(client|server)$/) {
                for (my $i = 1; $i <= scalar @{ $run{'iterations'} }; $i++) {
                    my $iter_params = dump_params($run{'iterations'}[$i - 1]{'params'});
                    for (my $s = 1; $s <= $run{'num-samples'}; $s++) {
                        my $iter_sampl_subpath = "iteration-" . $i . "/sample-" . $s;
                        my $cs_dest_sampl_path = $run_dir . "/iterations/" . $iter_sampl_subpath .
                                    "/" . $cs_type . "s/" . $cs_id;
                        make_path($cs_dest_sampl_path);
                        my $iter_sampl_dir = pushd($iter_sampl_subpath);
                        my $mv_cmd = "/bin/mv * " . $cs_dest_sampl_path;
                        my $mv_output = `$mv_cmd`;
                        if (my $pid = fork) {
                            push(@pids, $pid);
                        } else {
                            my $pushd_dir = pushd($cs_dest_sampl_path);
                            system($pp_cmd . " " . $iter_params);
                            exit;
                        }
                    }
                }
            }
            if (scalar dir_entries("tool-data", qr/\w+/) > 0) {
                my $tool_dir = pushd("tool-data");
                my $cs_tool_dest_path = $run_dir . "/tool-data/" . $cs_type . "/" . $cs_id;
                make_path($cs_tool_dest_path);
                my $mv_cmd = "/bin/mv * " . $cs_tool_dest_path;
                my $mv_output = `$mv_cmd`;
            }

            if (!$debug) {
                system("/bin/rm " . $archive_full_path);
            }
            # Must be cleaned up in every loop iteraiton
            system("/bin/rm -rf " . $tmp_data_dir . "/*");
        }
    }
    printf "Waiting for %d per-client/server post-processing jobs to complete\n", scalar @pids;
    while (wait() > -1) {
    }
    rmdir($tmp_data_dir);
}

# TODO: remove temporary ssh keys from local authorized_keys file

# These run details don't belong in the json we generate for the run
my $run_file = $run_dir . "/rickshaw-run.json";
for my $this_key (qw(bench-dir bench-params num-samples roadblock-dir
                     base-run-dir tool-params tools-dir workshop-dir tool-group)) {
    delete $run{$this_key};
}
$run{'rickshaw-run'}{'schema'}{'version'} = "2020.03.18";
put_json_file($run_file, \%run, $run_schema_file);
